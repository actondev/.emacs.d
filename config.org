#+PROPERTY: header-args :results silent :tangle yes

* Some defaults
** general
   #+BEGIN_SRC emacs-lisp
(menu-bar-mode 1) ;; show menu: useful things there some times!
(tool-bar-mode 0) ;; toolbar definetly not
(scroll-bar-mode 0) ;; hide system scrollbars

;; CUA
(cua-mode 0) ;; ctrl-c ctrl-v copy paste etc
(global-set-key (kbd "C-v") 'yank)

(global-hl-line-mode 1) ;; Highlight current line
(fset 'yes-or-no-p 'y-or-n-p)
;;(define-key cua-global-keymap [C-return] nil) ;; don't remember the use-case of this
;;(define-key cua--cua-keys-keymap [C-z] nil)
(global-visual-line-mode 1) ;; word/line wrap
(winner-mode t) ;; C-c left will undo window position changes

;; when (later) using a doom theme, this gets set to doom-themes-visual-bell-fn
(setq ring-bell-function 'ignore)

(global-display-line-numbers-mode 1)
(setq inhibit-startup-screen 1)
(delete-selection-mode 1) ;; delete selected region if starting typing

;; Keeping clipboard data before replacing it with emacs copy/kill etc
(setq save-interprogram-paste-before-kill t)

;; fixing fucking encoding things?
(prefer-coding-system 'utf-8)

(put 'narrow-to-region 'disabled nil)

;; showing help-at-point when idle
(setq help-at-pt-display-when-idle 't)
;; to actually take effect, the set timer must be called
(help-at-pt-set-timer)

;; to save slowdowns from long lines. added in emacs 27.1
(global-so-long-mode 1)

(setq find-file-visit-truename t)
   #+END_SRC

** functions
   #+BEGIN_SRC emacs-lisp
(defun indent-buffer ()
  (interactive)
  (save-excursion
    (indent-region (point-min) (point-max) nil)))

(defun toggle-comment-on-line ()
  "comment or uncomment current line"
  (interactive)
  (comment-or-uncomment-region (line-beginning-position) (line-end-position))
  )

(defun insert-buffer-name (buffer)
  (interactive
   (list
    (progn
      (barf-if-buffer-read-only)
      (read-buffer "Insert buffer name: "))))
  (insert buffer)
  nil)

(defun insert-timestamp ()
  (interactive)
  (let ((org-time-stamp-formats '("%Y-%m-%d" . "%Y-%m-%d %H:%M")))
    (call-interactively #'org-time-stamp)))
   #+END_SRC
** bindings
   #+BEGIN_SRC emacs-lisp
(defun aod/find-file ()
  (interactive)
  (if (eq major-mode 'dired-mode)
      (call-interactively #'find-file)
    (call-interactively #'find-file-at-point)))

(global-set-key (kbd "C-x C-f") 'aod/find-file)
(global-set-key (kbd "C-/") 'toggle-comment-on-line)
(global-set-key (kbd "C-?") 'comment-or-uncomment-region)
(global-set-key (kbd "C-S-b") 'recompile)

(require 'outline)
(global-set-key (kbd "M-n") 'outline-next-visible-heading)
(global-set-key (kbd "M-p") 'outline-previous-visible-heading)

;; making C-i not conflict with tab: not working?
;; (setq local-function-key-map (delq '(kp-tab . [9]) function-key-map))
   #+END_SRC
** backups
   - https://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files
   - https://www.emacswiki.org/emacs/BackupDirectory

   apparently the folder name needs a trailing slash, if not emacs continued to loitter the file directory (see https://emacs.stackexchange.com/questions/17210/how-to-place-all-auto-save-files-in-a-directory)
   
   #+BEGIN_SRC emacs-lisp
(defvar --backup-directory (concat user-emacs-directory "backups/"))
(if (not (file-exists-p --backup-directory))
    (make-directory --backup-directory t))
(setq backup-directory-alist `((".*" . ,--backup-directory)))

(setq auto-save-file-name-transforms
          `((".*" ,--backup-directory t)))

(setq make-backup-files t               ; backup of a file the first time it is saved.
      backup-by-copying t               ; don't clobber symlinks
      version-control t                 ; version numbers for backup files
      delete-old-versions t             ; delete excess backup files silently
      delete-by-moving-to-trash t
      kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
      kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
      auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      )   
   #+END_SRC
** compile
   #+begin_src emacs-lisp
(with-eval-after-load 'compile
  (setq compilation-scroll-output 'first-error
	compilation-always-kill t)
  (define-key compilation-mode-map (kbd "C-c C-c") #'kill-compilation))
   #+end_src
   Another option is =(setq compilation-scroll-output 'first-error)=
*** COMMENT troubleshoot
    #+begin_example emacs-lisp
 ;; had a problem with not scrolling..?
 (add-hook 'compilation-finish-functions
	   (lambda (buffer msg)
	     (message "compilation finished??")
	     (with-current-buffer buffer
	       (message "point max? %s" (point-max))
	       (goto-char (point-max)))))
    #+end_example
** mac modifiers
   #+begin_src emacs-lisp
(setq mac-command-modifier 'meta)
(setq mac-option-modifier nil)
   #+end_src
** native-comp
   #+begin_src emacs-lisp
(when (boundp 'byte-compile-warnings)
      (setq byte-compile-warnings nil))
(when (boundp 'comp-async-report-warnings-errors)
  (setq comp-async-report-warnings-errors nil))
   #+end_src
* Package source, use-package etc
  #+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)

(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
			 ("nongnu" . "https://elpa.nongnu.org/nongnu/")
			 ;;("org" . "https://orgmode.org/elpa/") ; better from gnu elpa, org-plus-contrib is at nongnu as org-contrib
			 ))
  #+END_SRC

** use-package
   Bootstrapping use-package
   #+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t
      use-package-always-defer t
      use-package-verbose 'verbose
      use-package-minimum-reported-time 0.01
      )
   #+END_SRC

** COMMENT quelpa (for git forks)
   #+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'quelpa)
  (with-temp-buffer
    (url-insert-file-contents "https://raw.githubusercontent.com/quelpa/quelpa/master/quelpa.el")
    (eval-buffer)
    ;;(quelpa-self-upgrade)
    ))
(setq quelpa-checkout-melpa-p nil)
(setq quelpa-update-melpa-p nil)

(use-package quelpa-use-package
  :demand t
  :init (setq quelpa-update-melpa-p nil)
  ;; i think (quelpa-use-package-activate-advice) made things fail
  ;; ie helm not being installed later on
  ;; :config (quelpa-use-package-activate-advice)
  )
   #+END_SRC

   and the =:quelpa= argument in =use-package= accepts a melpa recipe format:
   https://github.com/melpa/melpa#recipe-format
   #+BEGIN_EXAMPLE elisp
(<package-name>
 :fetcher [git|github|gitlab|hg]
 [:url "<repo url>"]
 [:repo "github-or-gitlab-user/repo-name"]
 [:commit "commit"]
 [:branch "branch"]
 [:version-regexp "<regexp>"]
 [:files ("<file1>" ...)])
   #+END_EXAMPLE

** COMMENT straight.el
   <2020-11-13 Fri> tried to set eval-in-repl to use my fork, and had errors.
   so not using straight :)
   see
   + https://github.crookster.org/switching-to-straight.el-from-emacs-26-builtin-package.el/
   + https://github.com/raxod502/straight.el/blob/develop/README.md#getting-started

   #+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
	(url-retrieve-synchronously
	 "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;;(setq straight-vc-git-default-clone-depth 1)
;; (setq straight-use-package-by-default nil)
(straight-use-package 'use-package)
   #+END_SRC

** el-get
   #+begin_src emacs-lisp
(use-package el-get
  :demand t
  :ensure t)
;; not really needed
;; (use-package use-package-el-get)
   #+end_src
** Custom directories
   Note: in [[file:init.el]] we defined the =relative-from-init= function.
   Here we add relative folders (from the init file) to load files from.
   + [ ] TODO add here something like a =custom= folder (which will be in gitignore)
   #+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (relative-from-init "elisp"))
   #+END_SRC
* Org customizations
  Note: (org-version) <2021-12-08 Wed>
  - 9.3 (emacs 27.1 elisp)
  - 9.4.6 https://orgmode.org/elpa/
  - 9.5.1 https://elpa.gnu.org/packages/
** configs with use-package
   #+begin_src emacs-lisp
;; removing from built-in: needed?
;; see https://www.reddit.com/r/emacs/comments/r11nqd/how_to_install_orgmode_now_that_org_emacs_lisp/
;; https://github.com/jwiegley/use-package/issues/319#issuecomment-845214233
(assq-delete-all 'org package--builtins)
(assq-delete-all 'org package--builtin-versions)

(use-package org
  :ensure t
  ;; ignore org-mode from upstream and use a manually installed version
  ;; was on :pin manual to use the built-in org?
  :pin gnu
  :config
  (setq org-src-preserve-indentation t
	org-startup-folded t
	org-adapt-indentation t

	;; there were bugs with this if t
	;; see https://lists.gnu.org/archive/html/emacs-orgmode/2019-12/msg00311.html
	;; fixed at https://code.orgmode.org/bzg/org-mode/commit/298d6332222258316aaa6b74699127eb97073ce2
	org-src-tab-acts-natively t
	org-context-in-file-links nil ;; org-store-link will just store file. add prefix arg to get also context
	)
  (setq org-log-note-clock-out t)
  (setq org-image-actual-width 400)
  ;; for <sTAB to work
  (require 'org-tempo)
  ;; org-goto with helm?
  (setq org-goto-interface 'outline-path-completion)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-ellipsis "â–¼")
  (unbind-key "C-," org-mode-map) ;; agenda (conflicts with C-, etc (my map)
  :bind (:map org-mode-map
	      ("C-M-p" . org-up-element)
	      ("C-M-n" . org-down-element)))    
   #+end_src
** org-contrib
#+begin_src emacs-lisp
(use-package org-contrib)
#+end_src
** habits
   #+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (add-to-list 'org-modules 'org-habit t))
   #+END_SRC 

   And add org-file to the list of agenda files.
   =(org-agenda-file-to-front)=
   see
   + https://orgmode.org/manual/Tracking-your-habits.html
   + https://www.youtube.com/watch?v=acj3NhXlnnk

   useful command
   + org-agenda-file-to-front
   + (setq org-log-done 'time)
** babel languages
   #+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (org-babel-do-load-languages 'org-babel-load-languages
			       '(
				 (shell . t)
				 (scheme . t)
				 (dot . t)
				 (plantuml . t)
				 ;;	  (python . t)
				 ;;	  (sql . t)
				 ;;	  (python . t)
				 ;;	  (restclient . t)
				 ;;	  (php . t)
				 ;;	  (clojure . t)
				 )
			       ))
   #+END_SRC
** plantuml
   #+begin_src emacs-lisp
(setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
   #+end_src

** (org-babel) eval-in-repl

*** el-get : my forks
    Just stating this before =use-package= makes it so that my fork is used.
    the =:config= etc from =use-package= calls work as expected
    #+begin_src emacs-lisp
(el-get-bundle eval-in-repl
   :type git
   :url "https://github.com/actonDev/eval-in-repl.git"
   :branch "feature/shell-and-term")

(el-get-bundle org-babel-eval-in-repl
   :type git
   :url "https://github.com/actondev/org-babel-eval-in-repl.git"
   :branch "feature/shell-and-term")
    #+end_src

*** installing with use-package
    #+BEGIN_SRC emacs-lisp
(use-package eval-in-repl
  ;; while developing:
  ;; :load-path "~/dev/github/eval-in-repl"

  ;; add ensure nil if using el-get
  :ensure nil
  )


(use-package org-babel-eval-in-repl
  ;; For the C-return command to work, we either have to "demand" or
  ;; require the package after org is loaded
  
  ;; while developing:
  ;; :load-path "~/dev/github/org-babel-eval-in-repl"

  ;; add ensure nil if using el-get
  :ensure nil

  :init
  (with-eval-after-load 'org
    (require 'org-babel-eval-in-repl))
  :commands (ober-eval-in-repl)
  :bind
  (:map org-mode-map
	;; ("C-<return>" . ober-eval-in-repl)
	))
    #+END_SRC

*** COMMENT el-get definitions
    another way to make this work..?
    #+begin_src emacs-lisp
;; needed
(require 'use-package-el-get)
(use-package-el-get-setup)

(setq el-get-sources
      
      '((:name org-babel-eval-in-repl :type git :url "https://github.com/actondev/org-babel-eval-in-repl.git" :branch "feature/shell-and-term" :after nil)
       (:name eval-in-repl :type git :url "https://github.com/actonDev/eval-in-repl.git" :branch "feature/shell-and-term" :after nil)))     

    #+end_src
*** TODO my mod: aod-eval-in-repl ??
    #+begin_src emacs-lisp
(use-package aod-eval-in-repl
  :load-path "elisp/aod-eval-in-repl/"
  :init
  (with-eval-after-load 'org
    (require 'aod-eval-in-repl))
  :bind (:map org-mode-map
	      ("C-<return>" . aod.eir/eval-org-src)
	      ("C-S-<return>" . aod.eir/eval-org-src-block)
	      ))
    #+end_src
** exporting to html
   #+BEGIN_SRC emacs-lisp
(use-package htmlize)
   #+END_SRC
** new moon calendar
   Maybe should use use-package
   This thing requires tiny
   =(require 'tiny)=
   #+BEGIN_SRC emacs-lisp
   ;; TODO not here??
;;(load-file (relative-from-init "elisp/aod-new-moon.el"))   
   #+END_SRC
** babel tangle append
   https://emacs.stackexchange.com/a/38898
   #+BEGIN_SRC emacs-lisp
(defun org-babel-tangle-append ()
  "Append source code block at point to its tangle file.
The command works like `org-babel-tangle' with prefix arg
but `delete-file' is ignored."
  (interactive)
  (cl-letf (((symbol-function 'delete-file) #'ignore))
    (org-babel-tangle '(4))))
   #+END_SRC

** github/gitlab style line links
   #+begin_src emacs-lisp
;;   see https://www.emacswiki.org/emacs/RegularExpression for regex
(defun aod.org/ad-open-file-git-line (orig path &optional in-emacs line search)
  "Makes it possible to open github/gitlab style links that point to certain lines
example: some-file.el#L10 -> links to some-file.el at line 10"
  (if (string-match "^\\(.+\\)#L\\([0-9]+\\)" path)
      (let ((just-path (match-string 1 path))
	    (line (match-string 2 path)))
	(funcall orig just-path nil (read line)))
    (funcall orig path in-emacs line search)))

(with-eval-after-load 'org
  (advice-add 'org-open-file :around #'aod.org/ad-open-file-git-line))
   #+end_src
** org hooks
   #+begin_src emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
   #+end_src
** helper: changing default-directory
   #+begin_src emacs-lisp
(defun aod/set-local-default-directory (arg)
  (interactive "P")
  (message "arg %s" arg)
  (if (and arg (boundp 'aod/original-default-directory))
      (progn
	(message "Reverting to %s" aod/original-default-directory)
	(setq-local default-directory aod/original-default-directory))
    (progn
      (unless (boundp 'aod/original-default-directory)
	(setq-local aod/original-default-directory default-directory)))
    (if-let ((dir (read-directory-name "Directory: ")))
	(setq-local default-directory dir)
      (when (boundp 'aod/original-default-directory)
	(message "Reverting to %s" aod/original-default-directory)
	(setq-local default-directory aod/original-default-directory)))))
   #+end_src
* COMMENT Helm
  #+BEGIN_SRC emacs-lisp
(setq aod.helm/C-SPC-set-mark-p nil)

(defun aod.helm/toggle-C-SPC ()
  "Toggles the functionality of C-SPC in helm-map"
  (interactive)
  (setq aod.helm/C-SPC-set-mark-p (not aod.helm/C-SPC-set-mark-p)))

(defun aod.helm/C-SPC ()
  "Either normal C-SPC (aka mark mini buffer input) or mark
multiple files"
  (interactive)
  (if aod.helm/C-SPC-set-mark-p
      (call-interactively 'set-mark-command)
    (helm-toggle-visible-mark-forward)))

(use-package helm
  :ensure t
  ;; dashboard: opening project file requires helm and helm-make-source
  :commands (helm helm-make-source)
  :bind(
	("M-x" . helm-M-x)
	("C-x C-f" . helm-find-files)
	("C-S-v" . helm-show-kill-ring)
	:map helm-map
	("<tab>" . helm-execute-persistent-action)
	("<left>" . left-char)
	("<right>" . right-char)
	:map helm-find-files-map
	("<left>" . left-char)
	("<right>" . right-char)
	;; to be able to select/copy filenames
	;; ("C-SPC" . set-mark-command)
	;; or be able to mark multiple files
	;;("C-SPC" . helm-toggle-visible-mark-forward)
	("C-SPC" . aod.helm/C-SPC)
	)
  :config
  (setq helm-M-x-fuzzy-match t
	helm-recentf-fuzzy-match t
	helm-apropos-fuzzy-match t
	helm-buffers-fuzzy-matching t
	helm-completion-in-region-fuzzy-match t
	helm-mode-fuzzy-match t)
  
  (setq helm-swoop-pre-input-function
	(lambda ()
	  ;; the default: thing-at-point
	  ;;(thing-at-point 'symbol)
	  (if mark-active
	      (buffer-substring-no-properties (region-beginning) (region-end))
	    nil)
	  ))
  
  (helm-mode 1)
  )

(use-package helm-swoop
  :config
  (setq helm-swoop-use-fuzzy-match nil)
  (setq helm-swoop-speed-or-color t)
  (setq helm-autoresize-max-height 35)
  (setq helm-autoresize-min-height 20)
  (setq helm-autoresize-mode 1)
  )

(use-package helm-ag)

  #+END_SRC

** installing ag (used in helm-ag)
   In ubuntu:
   #+BEGIN_SRC sh
sudo apt-get install silversearcher-ag
   #+END_SRC

* vertico, consult etc: ala helm
  
** vertico
   https://github.com/minad/vertico
   #+begin_src emacs-lisp
(use-package vertico
  ;; :hook (after-init . vertico-mode)
  :defer 0
  :config
  (vertico-mode)
  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
  
  (setq enable-recursive-minibuffers t)
  ;;(define-key vertico-map "<" nil)
  :bind (:map vertico-map
	      ("C-l" . aod/vertico-file-up)
	      ;; vertico was rebinding to history, instead I prefer to act as page-up page-down
	      ("<prior>" . nil)
	      ("<next>" . nil)
	      ("M-n" . next-history-element)
	      ("M-p" . previous-history-element)
	      ;; a-la helm (help-previous-source, helm-next-source)
	      ;; C-o (next), M-o prev

	      ;; (kbd "M-S-n") doesn't work, need [(meta shift n)] notation
	      ;; which doesn't work with :bind (which uses the bind-keys macro)
	      ;; see https://stackoverflow.com/questions/38140280/what-causes-m-s-t-meta-shift-t-key-binding-not-to-take
	      )
  :config
  (define-key vertico-map [(meta shift n)] #'vertico-next-group)
  (define-key vertico-map [(meta shift p)] #'vertico-previous-group)
  )

(defun aod/vertico-file-up (&optional n)
  "Delete N directories before point."
  (interactive "p")
  (when (and (> (point) (minibuffer-prompt-end))
	     ;; just comment out this part
             ;; (eq (char-before) ?/)
             (eq 'file (vertico--metadata-get 'category)))
    (let ((path (buffer-substring (minibuffer-prompt-end) (point))) found)
      (when (string-match-p "\\`~[^/]*/\\'" path)
	;; if we are at ~/ => absolute path
        (delete-minibuffer-contents)
        (insert (expand-file-name path)))
      (dotimes (_ n found)
        (save-excursion
          (let ((end (point)))
            (goto-char (1- end))
            (when (search-backward "/" (minibuffer-prompt-end) t)
              (delete-region (1+ (point)) end)
              (setq found t))))))))
   #+end_src
   
** orderless: fuzzy completion
   #+begin_src emacs-lisp
(use-package orderless
  :init
  ;; Configure a custom style dispatcher (see the Consult wiki)
  ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
  ;;       orderless-component-separator #'orderless-escapable-split-on-space)
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        ;; completion-category-overrides '((file (styles basic partial-completion)))
	;; completion-category-overrides '((file (styles orderless)))
	completion-category-overrides nil
	))
   #+end_src

   NOTE: about completion-category-overrides, had issues with fuzzy
   search when a file/dir would start with my search query. It would
   not give results having the search query in the middle, only the
   ones *starting* with it. If, however, no entry *starts* with the
   search query, I'd get the other results.

   https://github.com/oantolin/orderless
   #+begin_quote
Furthermore the basic completion style needs to be tried first (not as
a fallback) for TRAMP hostname completion to work. In order to achieve
that, we add an entry for the file completion category in the
completion-category-overrides variable. In addition, the
partial-completion style allows you to use wildcards for file
completion and partial paths, e.g., /u/s/l for /usr/share/local.
   #+end_quote

** consult
   tip:
   #+begin_src sh
sudo apt-get install ripgrep
   #+end_src
   
   #+begin_src emacs-lisp
(use-package consult
  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init
  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)
  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme
   :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-recent-file
   consult--source-project-recent-file
   :preview-key (kbd "M-."))

  ;; see https://github.com/minad/consult/issues/613
  (when (fboundp #'minibuffer-complete-history)
    (define-key consult-async-map [remap minibuffer-complete-history] 'consult-history))
  :bind (
	 ("C-S-v" . consult-yank-from-kill-ring)
	 )

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  ;; (setq consult-narrow-key "<") ;; (kbd "C-+")

  )
   #+end_src

** consult completion
   #+begin_src emacs-lisp
;; Use `consult-completion-in-region' if Vertico is enabled.
;; Otherwise use the default `completion--in-region' function.
(setq completion-in-region-function
      (lambda (&rest args)
        (apply (if vertico-mode
                   #'consult-completion-in-region
                 #'completion--in-region)
               args)))
   #+end_src
** marginalia
   #+begin_src emacs-lisp
;; Enable richer annotations using the Marginalia package
(use-package marginalia
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (:map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))

   #+end_src

** embark
   #+begin_src emacs-lisp
(use-package embark
  :ensure t

  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ;; ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  ;; (setq prefix-help-command #'embark-prefix-help-command)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  ;; (setq embark-quit-after-action '((kill-buffer . t) (t . nil)))
  (setq embark-quit-after-action nil)
  (require 'embark-consult)
  )

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :after (embark consult)
  )
   #+end_src
* Avy
  #+begin_src emacs-lisp
(use-package aod-read-multiple-choice
  :load-path "elisp/"
  ;; without demand t, and without bindigs
  ;; commands should be set: this will actually load the function
  :commands (aod/read-multiple-choice))

(defun aod/avy ()
  (interactive)
  (let ((choices '((?C "char (default)" avy-goto-char)
		   (?L "line" avy-goto-line)
		   (?W "word" avy-goto-word-1)
		   (?S "search" avy-goto-char-timer)
		   )))
    (let ((choice (aod/read-multiple-choice "avy action:" choices 'allow)))
      (if (listp choice)
	  (call-interactively (caddr choice))
	(progn
	  ;; (message "fallback, calling %s with %s" (caddar choices) choice)
	  (funcall (caddar choices) choice))))))

(use-package avy
  :config
  (setq avy-keys (list
		  ?a ?b ?c ?d ?e ?f ?g ?h ?i ?j ?k ?l ?m ?n ?o ?p ?q ?r ?s ?t ?u ?v ?w ?x ?y ?z))
  :bind (("M-s s" . avy-goto-char-timer)))
  #+end_src
* Window management
** Resizing (windresize)
   #+BEGIN_SRC emacs-lisp
(use-package windresize
  :config
  (setq windresize-default-increment 5)
  )
   #+END_SRC

** ace-window
   #+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind (("M-o" . ace-window))
  :config
  (setq-default aw-scope 'frame) ; switching windows only i current frame
  )
   #+END_SRC

** aod-window
   #+begin_src emacs-lisp
(use-package aod-window
  :load-path "elisp/"
  ;; without demand t, and without bindigs
  ;; commands should be set: this will actually load the function
  :commands (aod.window/place-buffer))
   #+end_src
** sessions, workgroups
   Tip:
   - =wg-save-session= when you have a nice window arrangement
   - =wg-open-session= to load it

   Don't know though the session/workgroup separation. what is what.
   (see all the =wg-xx-workgroup= methods)

     #+BEGIN_SRC emacs-lisp
(use-package workgroups2
  :commands (workgroups-mode wg-open-session)
  )
  #+END_SRC
** transpose-frame
   - flip-frame: Flip vertically
   - flop-frame: Flip horizontally


   #+begin_src emacs-lisp
(use-package transpose-frame)
   #+end_src
** Pinning windows
   Usecase: having the compilation buffer & commint (for program run) at bottom (for an IDE-like look). Calling =delete-other-windows= should keep those windows there (like pinned!)

   #+begin_src emacs-lisp
(use-package pin-mode
  :load-path "elisp/"
  :defer 0
  :config
  (global-pin-mode 1)
  (with-eval-after-load "minions"
    (add-to-list 'minions-prominent-modes 'global-pin-mode)))
   #+end_src

*** COMMENT old version
    #+begin_src emacs-lisp
(defun aod/pin-window (window)
  "Protects a window from being deleted with `delete-other-windows'"
  (interactive (list (selected-window)))
  (set-window-parameter window 'no-delete-other-windows t))

(defun aod/unpin-window (window)
  "Unprotects a window from being deleted with `delete-other-windows'"
  (interactive (list (selected-window)))
  (set-window-parameter window 'no-delete-other-windows nil))
    #+end_src
** tab-bar-mode
   Note: cannot just put the =aod.tab-bar/make-project-tab-bar-hook= code in here cause it needs lexical scoping (and the tangled blocks don't get it :/)

    #+begin_src emacs-lisp
(tab-bar-mode)
    #+end_src
*** COMMENT tab-bar-mode-hooks
    #+begin_src emacs-lisp
(use-package aod-tab-bar-hooks
  :load-path "elisp/"
  :defer 0
  :config
  (with-eval-after-load 'embark
    (fset 'aod/project-embark-hook (aod.tab-bar/make-project-tab-bar-hook "embark: "))
    (add-hook 'embark-after-export-hook 'aod/project-embark-hook))

  (with-eval-after-load 'magit
    (fset 'aod/project-magit-hook (aod.tab-bar/make-project-tab-bar-hook "magit: "))
    (add-hook 'magit-post-display-buffer-hook 'aod/project-magit-hook)))
    #+end_src

* Project management
** COMMENT Projectile
   Projetile MR <2021-07-30 Fri> https://github.com/bbatsov/projectile/pull/1696
  # until it's merged:
  # :load-path "~/dev/actondev/projectile/" ;; trailing slash is important
  # :ensure nil

   #+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-mode 1)
  ;; speed!
  (setq projectile-indexing-method 'hybrid)
  ;; (setq projectile-completion-system 'helm)
  ;; https://github.com/bbatsov/projectile/issues/1302#issuecomment-433894379
  ;; windows fix
  ;; (setq projectile-git-submodule-command nil)
  ;; oor install tr with "choco install tr"
  ;; oor msys2 paths (see heading)
  )
(defun aod.projectile/set-root (root)
  (interactive "Droot: ")
  (setq projectile-project-root root))

(use-package ag)

(defun aod.ag/vcs-ignore (&optional ignore-p)
  "TODO make it toggle
ag has a bug with .gitignore. encountered this in openFrameworks
see https://github.com/ggreer/the_silver_searcher/issues/862

So, when some files are not found, the .gitignore should be kept"
  (interactive (list nil))
  (require 'ag)
  (require 'helm-ag)
  (let* ((flag "--skip-vcs-ignores")
	 (ignore (cond ((numberp ignore-p) (if (= -1 ignore-p)
					       nil
					     t))
		       (t (progn (message "here") (not (member flag ag-arguments)))))))
    (if ignore
	(progn
	  (setq ag-arguments (cl-remove-if (lambda (x) (string-equal x flag))
					   ag-arguments))
	  (setq helm-ag-command-option nil))
      (progn
	(add-to-list 'ag-arguments flag)
	(setq helm-ag-command-option flag)))
    (message "new ag-arguments: %s
    new helm-ag-command-option %s"
	     ag-arguments
	     helm-ag-command-option)))

(use-package helm-projectile
  :commands (helm-projectile-find-file
	     helm-projectile-ag)
  :config (aod.ag/vcs-ignore t))

   #+END_SRC
** neotree
   Useful neotree shortcuts
   + =A= : stretch toggle
   + =U= : go up to parent
   + =C-c C-a= : collapse all
     + [ ] set <S-tab> for collapse all?

   #+begin_src emacs-lisp
(use-package neotree
  :config
  (defun display-line-numbers-disable-hook (_)
    "Disable display-line-numbers locally."
    (display-line-numbers-mode -1))
  
  (setq neo-smart-open t)
  (setq neo-window-fixed-size nil)
  (add-hook 'neo-after-create-hook 'display-line-numbers-disable-hook)
  :bind(
	("<f8>" . neotree-toggle)
	)
  )
   #+end_src
** projectile & dir locals
   #+begin_src emacs-lisp
(defun aod-project/reload-dir-locals ()
  (interactive)
  (dolist (buf (project-buffers (project-current)))
    (when (buffer-file-name buf)
      (with-current-buffer buf
	(message "hacking dir-locals into %s" buf)
	(hack-dir-local-variables-non-file-buffer)))))
   #+end_src
* Buffer management
** ibuffer : grouping by project
   #+BEGIN_SRC emacs-lisp
(use-package ibuffer-projectile
  :ensure t
  :hook
  (ibuffer .
	   (lambda ()
	     (ibuffer-projectile-set-filter-groups)
	     ;; TODO slow? not sure
	     ;; (unless (eq ibuffer-sorting-mode 'alphabetic)
	     ;;   (ibuffer-do-sort-by-alphabetic))
	     ))
  )
   #+END_SRC
** Get frame by name
   #+begin_src emacs-lisp
(defun get-frame-by-name (name)
  (find-if (lambda (frame) (equal (frame-parameter frame 'name) name))
	   (frame-list)))
   #+end_src
* Navigating
** cursor location history (go backwards/forwards): nice-jumper
   #+begin_src emacs-lisp
(use-package nice-jumper
  :defer 0
  :load-path "elisp/"
  ;; bindings ala intellij
  :config (nice-jumper-mode 1)
  :bind (("M-[" . nice-jumper/backward)
	 ("M-]" . nice-jumper/forward)))
   #+end_src
* Appearance
** Cursor
   #+BEGIN_SRC emacs-lisp
(blink-cursor-mode t)
(setq-default cursor-type '(bar . 3))
   #+END_SRC
** Welcome screen (dashboard)
   #+BEGIN_SRC emacs-lisp
(use-package dashboard
  ;; :init
  ;; (add-hook 'after-init-hook (lambda ()
  ;; 			       (require 'dashboard)))
  :demand t
  
  :diminish dashboard-mode
  :config
  (dashboard-setup-startup-hook)
  
  ;;  (setq dashboard-banner-logo-title "your custom text")
  (setq dashboard-startup-banner 1) ;; integer is for text
  (setq dashboard-items '(
			  (projects . 10)
                          (bookmarks . 10)
			  (recents  . 10)
			  ))
  
  ;; fixing emacs client starting with scratch
  ;; https://www.reddit.com/r/emacs/comments/8i2ip7/emacs_dashboard_emacsclient/
  (if (= 1 (length command-line-args))
      ;; going to dashboard only if we didn't pass a file
      (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*"))))
  )
   #+END_SRC
** frame title
   For distinguishing between windows and linux (WSL in windows)
   #+BEGIN_SRC emacs-lisp
;; note: can't use for some reason directy the system-type
(setq system-type-name (symbol-name system-type))
(setq frame-title-format '("%f  -- " system-type-name))
(defun aod/set-session-name (name)
  (interactive "Mname:")
  ;; making it persistent across frame
  ;; if I were to use the name directly that couldn't work
  (setq aod/session-name name)
  (setq frame-title-format `("" aod/session-name " -- %f  -- " system-type-name)))
   #+END_SRC
** COMMENT monokai
   #+BEGIN_SRC emacs-lisp
(use-package monokai-theme)
  

;; (use-package sublime-themes
;;   
;;   :config
;;   (load-theme 'spolsky t)
;;   )
   #+END_SRC
** doom
   #+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :demand t

  :config
  (load-theme 'doom-molokai t)
  (doom-themes-visual-bell-config)
  (doom-themes-neotree-config)
  ;; https://github.com/domtronn/all-the-icons.el/issues/28#issuecomment-312089198
  (setq inhibit-compacting-font-caches t)
  (setq doom-themes-neotree-file-icons t)
  )
   #+END_SRC
** doom-modeline
   #+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  ;; :hook (after-init . doom-modeline-mode)
  :defer 0
  :config
  (doom-modeline-mode)
  ;; border for modeline: had problem with org-mode src blocks (same color)
  (custom-set-faces
   '(mode-line ((t (:box (:line-width 1 :color "dim gray"))))))
  ;; till https://github.com/seagle0128/doom-modeline/issues/503
  ;; (doom-modeline-def-modeline 'project
  ;;   '(bar window-number modals buffer-default-directory)
  ;;   '(misc-info battery irc mu4e gnus github debug minor-modes input-method major-mode process))
  (doom-modeline-def-modeline 'dashboard
    '(bar window-number modals buffer-default-directory-simple)
    '(misc-info battery irc mu4e gnus github debug minor-modes input-method major-mode process)))
   #+END_SRC

   + [ ] TODO
     If sometimes you don't see the icons (it happens on doom-modeline reset and enable again)
   #+BEGIN_SRC emacs-lisp :tangle no
;; (setq doom-modeline-icon (display-graphic-p))
(setq doom-modeline-buffer-state-icon t)
   #+END_SRC
** all-the-icons
   #+begin_src emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p))
   #+end_src

   Note: after you have to run =all-the-icons-install-fonts= with M-x.
*** minions: showing minor modes
    https://github.com/tarsius/minions
    A minor-mode menu for the mode line

    #+BEGIN_SRC emacs-lisp
(use-package minions
  ;; :hook (after-init . minions-mode)
  :defer 0

  :config
  (minions-mode 1)
  (setq doom-modeline-minor-modes (featurep 'minions)))
    #+END_SRC
** COMMENT powerline
   #+BEGIN_SRC emacs-lisp
(use-package powerline
  :config
  (powerline-default-theme))
   #+END_SRC

** highlighting matching tag (show-paren)
   #+BEGIN_SRC emacs-lisp
(use-package paren
  :hook (prog-mode . show-paren-mode)
  :init
  (set-face-attribute 'show-paren-match nil
		      :box '(:line-width -1 :color "#ccc")
		      :foreground nil
		      :weight 'normal))
   #+END_SRC
** flashing / highlighting
   #+BEGIN_SRC emacs-lisp
(use-package nav-flash
  :config
  (custom-set-faces
   '(nav-flash-face ((t (:background "#666" :foreground nil))))))
   #+END_SRC
** coloring background for PRODUCTION, STAGING
   #+begin_src emacs-lisp
(defun aod.devops/color-buffer ()
  "Set background color for *PROD* or *STAG* (staging) buffers"
  (let ((case-fold-search nil))
    (when (or
	   (string-match-p ".*PROD.*" (buffer-name))
	   (string-match-p ".*STAG.*" (buffer-name))
	   (string-match-p ".*DEV.*" (buffer-name)))
      (face-remap-add-relative 'default :background "#300")
      )))

;; (add-hook 'find-file-hook #'aod.devops/color-buffer)
(add-hook 'after-change-major-mode-hook #'aod.devops/color-buffer)
   #+end_src
** highlight regexp with string (overlay)
   #+begin_src emacs-lisp
(defun aod/highlight-regexp-with-string (overlay-name regexp string &optional face)
  "Display each match of REGEXP as STRING with face FACE.
Uses OVERLAY-NAME (symbol) as the overlay name.
Credit: https://emacsnotes.wordpress.com/2018/10/26/highlight-text-not-with-faces-but-with-other-texts/"
  (interactive
   (list
    (read-string "Overlay name: ")
    (read-regexp "Regexp: ")
    (intern (read-string "Replacement: "))
    regexp string  (hi-lock-read-face-name)))
  (setq face (or face 'highlight))
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search nil))
      (while (re-search-forward regexp nil t)
        (let ((ov (make-overlay (match-beginning 0) (match-end 0))))
          (overlay-put ov overlay-name t)
          (overlay-put ov 'display string)
          (overlay-put ov 'face face))))))

(defun aod/unhighlight (overlay-name)
  "Calls remove-overlays with the overlay-name (symbol)"
  (interactive
   (list
    (intern (read-string "Overlay name: "))))
  (remove-overlays nil nil overlay-name t))

(defun aod/highlight-multiple (overlay-name face &rest args)
  "example args ('my-overlay 'highlight \"regexp1\" \"text1\" \"regexp2\" \"text2\" ...)"
  (when args
    (aod/highlight-regexp-with-string overlay-name (car args) (cadr args) face)
    (apply #'aod/highlight-multiple overlay-name face (cddr args))))
   #+end_src
* editing etc
** linear ranges (tiny)
   #+BEGIN_SRC emacs-lisp
(use-package tiny)
   #+END_SRC
** auto completion
*** company
    #+BEGIN_SRC emacs-lisp
(use-package company
  ;; :hook (after-init . global-company-mode)
  :defer 0
  :config
  (global-company-mode)
  (setq company-dabbrev-downcase nil)
  (setq company-dabbrev-ignore-case t))
    #+END_SRC
*** COMMENT corfu
    #+begin_src emacs-lisp
(use-package corfu
  :custom
  (corfu-auto t)          ;; Enable auto completion
  ;; (corfu-separator ?_) ;; Set to orderless separator, if not using space
  :bind
  ;; Another key binding can be used, such as S-SPC.
  ;; (:map corfu-map ("M-SPC" . corfu-insert-separator))
  :init
  (global-corfu-mode))
    #+end_src
** Hiding/showing blocks
   + [[file:emacs-lisp/hideshowvis.el]]
     adds clickable + - icons in the left fringe for folding/unfolding (hiding/showing) code blocks
   + [[file:emacs-lisp/hideshow-org.el]]
     adds functionality similar to org-mode: toggle code block hide/show by pressing tab
   #+BEGIN_SRC emacs-lisp
(use-package hideshow-org
  ;; https://github.com/shanecelis/hideshow-org
  :load-path "elisp/"
  ;; :hook (prog-mode . hs-org/minor-mode)
  )

(defvar aod.hs/hide-show-all-next nil)
(defun aod.hs/hideshow-all ()
  (interactive)
  (if aod.hs/hide-show-all-next
      (hs-show-all)
    (hs-hide-all))
  (setq-local aod.hs/hide-show-all-next (not aod.hs/hide-show-all-next)))

(defun aod.hs/toggle-line ()
  (interactive)
  (save-excursion
    (if (hs-already-hidden-p)
	(hs-show-block)
      (end-of-line)
      (hs-hide-block))))

;; ooor
;; pressing tab in the beggigning of the line -> hideshow
;; else, indent or whatever?

;; (let ((other-keys hs-org/trigger-keys-block))
;;   (while (and (null command)
;;               (not (null other-keys)))
;;     (setq command (key-binding (car other-keys)))
;;     (setq other-keys (cdr other-keys)))
;;   (when (commandp command)
;;     (call-interactively command)))

(use-package hideshowvis
  ;; https://www.emacswiki.org/emacs/hideshowvis.el
  :load-path "elisp/"
  :hook (prog-mode . hideshowvis-minor-mode)
  :bind (:map prog-mode-map
	      ("C-<tab>" . aod.hs/toggle-line)
	      ("<backtab>" . aod.hs/hideshow-all) ;; shift+tab
	      ("C-S-<iso-lefttab>" . hs-hide-level) ;; ctrl+shift+tab
	      ("C-S-<tab>" . hs-hide-level) ;; for macos
	      ))
   #+END_SRC

** selection
   #+BEGIN_SRC emacs-lisp
;; usecase: select the block (enclosed by parenthesis).. expand -> wrap around the outter block
(use-package expand-region)

(use-package multiple-cursors
  :bind (("C->" . mc/mark-next-like-this-word)
	 ("C-<" . mc/mark-previous-like-this-word)
	 ( "M-<f3>" . mc/mark-all-like-this) ;; submlime like
	 ("C-S-<mouse-1>" . mc/add-cursor-on-click))
  )
   #+END_SRC
** undo
   Note: for some reason =C-_= (which original runs =undo=) gets
   rebound to =undo-tree-undo= and I cannot in *ANY* way to bind it
   back to the original =undo=
   #+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :config
  (global-undo-tree-mode 1)
  ;; it's buggy actually and messes with the normal undo
  ;; which works great when there's a region selected
  ;; https://emacs.stackexchange.com/a/37399/19673
  ;;(setq undo-tree-enable-undo-in-region t)
  (unbind-key "C-/" undo-tree-map)
  (unbind-key "C-?" undo-tree-map)
  :bind(
	("M-/" . undo-tree-visualize)
	("C-z" . undo-tree-undo)
	("C-S-z" . undo-tree-redo))
  :config
  (defvar --undo-tree-history-directory (concat user-emacs-directory "undo-tree/"))
  (if (not (file-exists-p --undo-tree-history-directory))
      (make-directory --undo-tree-history-directory t))
  (setq undo-tree-history-directory-alist `((".*" . ,--undo-tree-history-directory))))
   #+END_SRC

** Working with lisps
*** paredit
    #+BEGIN_SRC emacs-lisp
(use-package paredit
  ;; <C-right>	paredit-forward-slurp-sexp
  ;; <C-left>	paredit-forward-barf-sexp
  ;; <C-M-right>	paredit-backward-barf-sexp
  ;; <C-M-left>	paredit-backward-slurp-sexp  :config
  :hook ((clojure-mode emacs-lisp-mode scheme-mode ) . paredit-mode)
  :config
  (unbind-key "C-<right>" paredit-mode-map)
  (unbind-key "C-<left>" paredit-mode-map)
  (unbind-key "M-s" paredit-mode-map) ;; paredit-splice-sexp
  :bind(:map paredit-mode-map
	     ;; Note: using M-] M-[ for nice-jumper (go backwards/forwards)
	     ;;
	     ;; ("M-]" . paredit-forward-slurp-sexp) ;; c ->
	     ;; ("M-[" . paredit-forward-barf-sexp) ;; c <-
	     ;; ("M-}" . paredit-backward-barf-sexp) ;; C-M >
	     ;; ("M-{" . paredit-backward-slurp-sexp) ;; C M <
	     ("M-<right>" . paredit-forward-slurp-sexp)
	     ("M-<left>" . paredit-forward-barf-sexp)
	     ("M-S-<right>" . paredit-backward-barf-sexp)
	     ("M-S-<left>" . paredit-backward-slurp-sexp)
	     ;;
	     ))
    #+END_SRC
    Useful tricks
    + swapping parens to brackets etc
      https://stackoverflow.com/a/24784563/8720686
*** COMMENT parinfer
    #+BEGIN_SRC emacs-lisp
(defun add-parinfer-hooks ()
  (add-hook 'clojure-mode-hook #'parinfer-mode)
  (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
  (add-hook 'common-lisp-mode-hook #'parinfer-mode)
  (add-hook 'scheme-mode-hook #'parinfer-mode)
  (add-hook 'lisp-mode-hook #'parinfer-mode))

(use-package parinfer
  :bind
  (("C-," . parinfer-toggle-mode))
  :init
  (progn
    (setq parinfer-extensions
          '(
	    defaults       ; should be included.
            ;; pretty-parens  ; different paren styles for different modes.
            ;; evil           ; If you use Evil.
            ;; lispy          ; If you use Lispy. With this extension, you should install Lispy and do not enable lispy-mode directly.
            
paredit        ; Introduce some paredit commands.
            smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
            smart-yank
	    ))   ; Yank behavior depend on mode.
    ))
    #+END_SRC
*** aggresive indent?
    https://github.com/Malabarba/aggressive-indent-mode
    vs electric
    #+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :hook ((clojure-mode emacs-lisp-mode) . aggressive-indent-mode)
  )
    #+END_SRC
** jumping around (ace jump)

   #+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :config
  (setq-default ace-jump-mode-scope 'frame) ; jumping only in current frame
  )
   #+END_SRC
** Rainbow
   Rainbow-mode is for previewing hex color strings in any buffer! :)
   had problems around <2020-05-07 Thu> . the .el file was.. empty??
   #+BEGIN_SRC emacs-lisp
(use-package rainbow-mode)
   #+END_SRC

   Rainbow-delimiters are here to save the day for lisps! (and not only)
   Highlighting matching pairs with different colors
   #+BEGIN_SRC emacs-lisp
;; cause in the default colors there was some white cursors, not really apparent
'(((((((((())))))))))

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode)
  :config
  ;; (my-rainbow-custom-colors)
  (set-face-attribute 'rainbow-delimiters-depth-1-face nil
		      :foreground "#e91e63")
  (set-face-attribute 'rainbow-delimiters-depth-2-face nil
		      :foreground "#2196F3")
  (set-face-attribute 'rainbow-delimiters-depth-3-face nil
		      :foreground "#EF6C00")
  (set-face-attribute 'rainbow-delimiters-depth-4-face nil
		      :foreground "#B388FF")
  (set-face-attribute 'rainbow-delimiters-depth-5-face nil
		      :foreground "#76ff03")
  (set-face-attribute 'rainbow-delimiters-depth-6-face nil
		      :foreground "#26A69A")
  (set-face-attribute 'rainbow-delimiters-depth-7-face nil
		      :foreground "#FFCDD2")
  (set-face-attribute 'rainbow-delimiters-depth-8-face nil
		      :foreground "#795548")
  (set-face-attribute 'rainbow-delimiters-depth-9-face nil
		      :foreground "#DCE775")
  )
   #+END_SRC

** LSP: Language Server Protocol
   #+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :commands lsp
  :init
  ;; Not sure actually why I have this here
  ;; (setq lsp-enable-indentation nil)
  :config
  (add-to-list 'lsp-language-id-configuration '(clojure-mode . "clojure-mode"))
  (setq gc-cons-threshold 100000000 ;; was 800000 by default
	read-process-output-max (* 1024 1024) ;; 1MB
	;; these 2 seem to make buffer code navigation quite slow!
	lsp-lens-auto-enable nil
	lsp-headerline-breadcrumb-enable nil
	;; the end
	))

(use-package lsp-ui
  :commands lsp-ui-mode)

;; <2021-07-07 Mi> not working
;; (use-package company-lsp
;;   :commands company-lsp)
   #+END_SRC

*** ccls
    #+begin_src emacs-lisp
(use-package ccls
  :after (lsp-mode)
  :config (add-to-list 'lsp-client-packages 'ccls)
  ;; :config (setq lsp-disabled-clients '(clangd))
  )
;; (use-package ccls)
;; (require 'ccls)
    #+end_src

*** COMMENT disabling lsp clients
    #+begin_src emacs-lisp
(setq lsp-disabled-clients '(clangd))
(setq lsp-disabled-clients '(ccls))
    #+end_src

*** COMMENT lsp clang
    To get the latest clang:
    #+begin_src sh :tangle no
wget https://apt.llvm.org/llvm.sh

chmod +x llvm.sh
sudo ./llvm.sh
    #+end_src

    #+begin_src emacs-lisp
(with-eval-after-load 'lsp-clangd
  (unless lsp-clients-clangd-executable
    (message "Trying to set clang executable")
    (let ((vscodium-clang "~/.config/VSCodium/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/11.0.0/clangd_11.0.0/bin/clangd"))
      (message "here %s" vscodium-clang)
      (if (file-exists-p vscodium-clang)
	  (progn
	    (setq lsp-clients-clangd-executable vscodium-clang)
	    (message "Clang executable set to %s" vscodium-clang))
	(warn "Clang could not be found in %s" vscodium-clang)))))
    #+end_src
** Linting
   Flycheck: checking only when saving (not when editing the file - can cause slowness)
   #+BEGIN_SRC emacs-lisp
(use-package flycheck
  
  :config
  (setq flycheck-check-syntax-automatically '(save mode-enabled))
  )
   #+END_SRC
** HEX colors
   an alternative to rainbow-mode? 
   #+BEGIN_SRC emacs-lisp :tangle no
   (load-file (relative-from-init "elisp/xah.el"))
   #+END_SRC
   And now you can call the =xah-syntax-color-hex= function in any buffer :)
   Found at http://ergoemacs.org/emacs/xah-css-mode.html
** Writing - center text
   When writing a post, article or whatever, I don't want lines to extend all across the screen.
   
   credits: https://bzg.fr/en/emacs-strip-tease.html/
   
   #+BEGIN_SRC emacs-lisp
;; A small minor mode to use a big fringe
(defvar bzg-big-fringe-mode nil)
(define-minor-mode bzg-big-fringe-mode
  "Minor mode to use big fringe in the current buffer."
  :init-value nil
  :global t
  :variable bzg-big-fringe-mode
  :group 'editing-basics
  (if (not bzg-big-fringe-mode)
      (set-fringe-style nil)
    (set-fringe-mode
     (/ (- (frame-pixel-width)
           (* 100 (frame-char-width)))
        2))))

   #+END_SRC
** TODO Writing - spelling
   TBD
** snippets (yasnippet)
   #+begin_src emacs-lisp
(use-package yasnippet
  ;; :hook (prog-mode . yas-minor-mode)
  ;; :init
  ;; (add-hook 'after-init-hook (lambda ()
  ;; 			      (message "here yasnippet")
  ;; 			     (require 'yasnippet)))
  :defer 0
  :config
  (yas-global-mode 1)
  )
   #+end_src
** epoch, ms, seconds etc
   #+begin_src emacs-lisp
(defun epoch-at-point ()
  (interactive)
  (let* ((bounds (if (region-active-p)
		     (car (region-bounds))
		   (bounds-of-thing-at-point 'word)))
	 (seconds (read (buffer-substring-no-properties (car bounds)
							(cdr bounds)))))
    (when (> seconds (+ (time-to-seconds (current-time))
			(* 31622400 1000 ;; 1000 years in seconds: https://www.rapidtables.com/calc/time/seconds-in-year.html
			   )))
      (message "assuming epoch in milliseconds")
      (setq seconds (/ seconds 1000)))
    (message "%s => %s" seconds (format-time-string "%F %r" (seconds-to-time seconds)))
    (unless buffer-read-only
      (put-text-property (car bounds) (cdr bounds)
			 'help-echo (format-time-string "%F %r" (seconds-to-time seconds))))))

(defun milliseconds-at-point ()
  (interactive)
  (let* ((bounds (if (region-active-p)
		     (car (region-bounds))
		   (bounds-of-thing-at-point 'word)))
	 (ms (read (buffer-substring-no-properties (car bounds)
						   (cdr bounds))))
	 (duration-string (let ((org-duration-format 'h:mm:ss))
			    (org-duration-from-minutes (/ ms 1000.0 60.0)))))
    (message "%s ms => %s (h:mm:ss)" ms duration-string)
    (unless buffer-read-only
      (put-text-property (car bounds) (cdr bounds)
			 'help-echo duration-string))))

(defun seconds-at-point ()
  (interactive)
  (let* ((bounds (if (region-active-p)
		     (car (region-bounds))
		   (bounds-of-thing-at-point 'word)))
	 (seconds (read (buffer-substring-no-properties (car bounds)
							(cdr bounds))))
	 (duration-string (let ((org-duration-format 'h:mm:ss))
			    (org-duration-from-minutes (/ seconds 60.0)))))
    (message "%s s => %s (h:mm:ss)" seconds duration-string)
    ;; (unless buffer-read-only
    ;;   (put-text-property (car bounds) (cdr bounds)
    ;; 			 'help-echo duration-string))
    ))
   #+end_src
** demo: hex/dec etc
   #+begin_src emacs-lisp
(defun dec->hex (dec)
  "eg 7f => 127, 017f => 383"
  (interactive (list (string-to-number (if (region-active-p)
					   (buffer-substring-no-properties
					    (caar (region-bounds))
					    (cdar (region-bounds)))
					 (buffer-substring-no-properties
					  (point)
					  (+ 2 (point)))))))
  (message "dec %s => hex %x" dec dec)
  (format "%x" dec))

(defun hex->dec (hex)
  "eg 7f => 127, 017f => 383"
  (interactive (list (if (region-active-p)
			 (buffer-substring-no-properties
			  (caar (region-bounds))
			  (cdar (region-bounds)))
		       (buffer-substring-no-properties
			(point)
			(+ 2 (point))))))
  (message "hex %s => dec %s" hex (string-to-number hex 16))
  )

(defun int-to-binary-string (i)
  "convert an integer into it's binary representation in string format"
  (let ((res ""))
    (while (not (= i 0))
      (setq res (concat (if (= 1 (logand i 1)) "1" "0") res))
      (setq i (lsh i -1)))
    (if (string= res "")
        (setq res "0"))
    res))

(defun format-binary (b)
  (let ((s ""))
    (while (> b 0)
      (setq s (concat (number-to-string (logand b 1)) s))
      (setq b (lsh b -1)))
    (if (string= "" s) "0" s)))

(defun hex->bin (hex)
  (interactive (list (if (region-active-p)
			 (buffer-substring-no-properties
			  (caar (region-bounds))
			  (cdar (region-bounds)))
		       (buffer-substring-no-properties
			(point)
			(+ 2 (point))))))
  (message "hex %s => dec %s bin %s" hex
	   (string-to-number hex 16)
	   (format-binary (string-to-number hex 16)))
  )


(defun bin->dec (bin)
  (interactive (list (if (region-active-p)
			 (buffer-substring-no-properties
			  (caar (region-bounds))
			  (cdar (region-bounds)))
		       (buffer-substring-no-properties
			(point)
			(+ 2 (point))))))
  (message "bin %s => dec %s" bin (string-to-number bin 2))
  )
   #+end_src
   #+end_src
** uuid-at-point
   #+begin_src emacs-lisp
(defun uuid-at-point ()
  (save-excursion
    (search-backward-regexp "[^0-9a-f\-][0-9a-f]")
    (forward-char)
    (let ((start (point)))
      (search-forward-regexp "[0-9a-f][^0-9a-f\-]")
      (backward-char)
      (let ((region-string (buffer-substring-no-properties start (point)))
	    (uuid-regex "^[0-9a-f]\\{8\\}-[0-9a-f]\\{4\\}-[0-9a-f]\\{4\\}-[0-9a-f]\\{4\\}-[0-9a-f]\\{12\\}$"))
	(if (string-match-p uuid-regex region-string)
	    region-string
	  (error "no uuid at point"))))))
   #+end_src
* UI
** hydra
   #+begin_src emacs-lisp
(use-package hydra)
   #+end_src
** transient
   #+begin_src emacs-lisp
(use-package transient
  :commands (define-transient-command
	      transient-define-prefix
	      transient-define-suffix
	      transient-define-argument)
  :config
  (defun aod.transient/flag (transient-name flag)
    (cl-find-if (lambda (el)
		  (string-equal flag el))
		(transient-args transient-name)))
  
  (defun aod.transient/param (marker transient-params)
    "Extract from TRANSIENT-PARAMS the argument with MARKER."
    (cl-find-if
     (lambda (an-arg) (string-prefix-p marker an-arg))
     transient-params))

  (defun aod.transient/param-value (marker transient-params)
    "Extract from TRANSIENT-PARAMS the argument with MARKER."
    (cl-some
     (lambda (an-arg) (when (string-prefix-p marker an-arg)
			(replace-regexp-in-string marker
                                                  ""
                                                  an-arg)))
     transient-params)))
   #+end_src
* Hacking around
** custom local variables
   #+begin_src emacs-lisp
(defun aod/local-variables ()
  "Getting 'custom' local variables (eg REMOTE_ENDPOINT).
Setting them into buffers for working with org-mode & repls"
  (interactive)
  (let ((res
	 (delq nil
	       (mapcar
		(lambda (x)
  		  ;; Most elements look like (SYMBOL . VALUE), describing one variable.
		  ;; For a symbol that is locally unbound, just the symbol appears in the value
		  (when (not (symbolp x))
		    (let ((name (symbol-name (car x))))
		      (when (or (s-uppercase? name)
				(s-match "^\*" name))
			x))))
		(buffer-local-variables)))))
    (if (called-interactively-p 'interactive)
	(message "%S" res)
      res)))
   #+end_src
** reading buffer with modes
   #+begin_src emacs-lisp
(defun aod/read-buffer-with-modes (prompt modes)
  (read-buffer prompt nil nil
	       (lambda (x)
		 (with-current-buffer x
		   (memq major-mode modes)))))
   #+end_src
** network, nmap
   #+begin_src emacs-lisp
(defun aod/ssh-local-hosts ()
  "Scans local network for hosts with port 22 open"
  (let* ((host-out (shell-command-to-string "hostname -I")))
    (string-match "\\([^ ]+\\)" host-out)
    (let* ((host-ip (match-string 0 host-out))
	   (_ (message "scanning for hosts in %s/24" host-ip))
	   ;; T5: insane mode (fastest)
	   (nmap-out (shell-command-to-string (format "nmap -p22 -T5 %s/24" host-ip))))
      (with-temp-buffer
	(insert nmap-out)
	(beginning-of-buffer)
	(let ((dict nil))
	  (while (re-search-forward "Nmap scan report for \\([^ ]+\\) (\\([0-9.]+\\))"
				    nil 'no-error)
	    (push (cons (match-string-no-properties 1)
			(match-string-no-properties 2))
		  dict))
	  dict)))))

(defun aod/read-or-insert-ssh-local-host ()
  (interactive)
  (let* ((hosts (aod/ssh-local-hosts))
	 (sel (helm-comp-read "host: " (mapcar (lambda  (x)
						 (cons (format "%s (%s)" (car x) (cdr x))
						       (cdr x)))
					       hosts))))
    (if (interactive-p)
	(insert sel)
      sel)))
   #+end_src
* Utilities (vterm..)
** vterm
   - [ ] check --with-modules support

   #+BEGIN_SRC emacs-lisp
(use-package vterm
  :config
  (setq vterm-max-scrollback 10000) ; 1000 (1k) was the default, max allowed is 100k
  (defun aod-vterm/clear ()
    (interactive)
    (vterm-clear)
    (vterm-clear-scrollback))
  :bind (:map vterm-mode-map
	      ("C-c C-l" . aod-vterm/clear)
	      ;; hm.. when in copy mode, enter will
	      ;; - copy region (kill-ring-save)
	      ;; - exit from copy mode
	      ;; .. that's enough no?
	      ;;("M-w" . kill-ring-save)
	      ))
   #+END_SRC
*** TODO copy mode: C-c C-t
    - [ ] bind to =C-c j= ala line mode for term.
    - [ ] minion: show =vterm-copy-mode= (if it's not show something else?)
*** vterm info
    #+begin_quote
    C-c C-c runs the command vterm-send-C-c (found in vterm-mode-map),
which is an interactive Lisp function in â€˜vterm.elâ€™.
It is bound to C-c C-c.

(vterm-send-C-c)
    #+end_quote
*** vterm installation notes
   #+BEGIN_QUOTE
   VTerm needs module support.  Please compile Emacs with the
  --with-modules option!
   #+END_QUOTE

   also, you need the following to compile the module (ubuntu example)
   #+begin_src sh
sudo apt-get install cmake libtool-bin -y
   #+end_src

* ediff
  Ediff: great diff tool that can be used in magit :)
  Customizing colors cause in doom-molokai theme you could't notice anything
  #+BEGIN_SRC emacs-lisp
(use-package ediff
  :hook (ediff-prepare-buffer . show-all)
  :config
  (setq ediff-split-window-function 'split-window-horizontally
	ediff-window-setup-function 'ediff-setup-windows-plain
	ediff-autostore-merges t)
  ;; ?? the buffer-read-only was commented out.. 27 years ago!?
  ;; 92c51e075e8bc9c2ace8487bfc42f23389d09b73
  ;; AuthorDate: Fri Sep 20 01:10:05 1996 +0000
  (defconst ediff-protected-variables '(
				      buffer-read-only
				      mode-line-format))

  ;; A head (last commit)
  (set-face-attribute 'ediff-current-diff-A nil
		      :background "#8b0000"
		      :foreground "#CCC")
  ;; B index (stage)
  (set-face-attribute 'ediff-current-diff-B nil
		      :background "#008b00"
		      :foreground "#CCC")
  ;; C working tree
  (set-face-attribute 'ediff-current-diff-C nil
		      :background "#8b5a00"
		      :foreground "#CCC")

  ;; (defun ediff-copy-both-to-C ()
  ;;   (interactive)
  ;;   (ediff-copy-diff ediff-current-difference nil 'C nil
  ;;                    (concat
  ;;                     (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
  ;;                     (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
  ;; (defun add-d-to-ediff-mode-map () (define-key ediff-mode-map "d" 'ediff-copy-both-to-C))
  ;; (add-hook 'ediff-keymap-setup-hook 'add-d-to-ediff-mode-map)
  
  )
  #+END_SRC

* Magit
  #+BEGIN_SRC emacs-lisp
(use-package magit
  ;; show-all is meant for org-mode. ediff would show org-mode files folded
  :config
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (set-face-attribute 'magit-branch-current nil
		      :underline t))
  #+END_SRC

** show untracked files
   #+begin_src sh
git config --global status.showUntrackedFiles all
# revert:
git config --global status.showUntrackedFiles normal
# see more at
man git-commit | grep untracked
   #+end_src
* Languages
** Clojure
   #+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :bind(
	:map clojure-mode-map
	("C-<return>" . cider-eval-defun-at-point)
	("M-<return>" . cider-eval-last-sexp)
	)
  )
   #+END_SRC

*** repl (cider etc)
    Cider is amazing :)
    #+BEGIN_SRC emacs-lisp
(use-package cider)

(use-package clj-refactor
  ;; WIP
  :commands (clj-refactor-mode))
    #+END_SRC
*** Linting
    Note: have to install =clj-kondo= with =npm install -g clj-kondo=
    #+BEGIN_SRC emacs-lisp
(use-package flycheck-clj-kondo
  :init
  (with-eval-after-load 'flycheck
    (require 'flycheck-clj-kondo))
  )
    #+END_SRC

** Scheme
   #+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.sls\\'" . scheme-mode))
(defun aod/scheme-name->cpp (name)
  (->> name
       (replace-regexp-in-string "-" "_")
       (replace-regexp-in-string "!" "_bang")))
   #+END_SRC

   custom hightlight
   #+begin_src emacs-lisp
 (defun scheme-add-keywords (face-name keyword-rules)
   (let* ((keyword-list (mapcar #'(lambda (x)
                                    (symbol-name (cdr x)))
                                keyword-rules))
          (keyword-regexp (concat "(\\("
                                  (regexp-opt keyword-list)
                                  "\\)[ \n]")))
     (font-lock-add-keywords 'scheme-mode
                             `((,keyword-regexp 1 ',face-name))))
   (mapc #'(lambda (x)
             (put (cdr x)
                  'scheme-indent-function
                  (car x)))
         keyword-rules))
   #+end_src

   #+begin_src emacs-lisp
(scheme-add-keywords
 'font-lock-keyword-face
 '((1 . lambda*)
   (1 . error)
   (0 . comment)
   (1 . when-let)
   (1 . when-let*)
   (1 . if-let)
   (1 . if-let*)
   ))
   #+end_src

** Repls (comint)
#+begin_src emacs-lisp
(use-package comint
  :pin manual ;; built-in?
  :ensure nil ;; ??
  :bind
  (:map comint-mode-map
	("C-c C-l" . comint-clear-buffer)))
#+end_src

TODO
#+begin_src emacs-lisp
'(bind-key "C-c C-l" #'comint-clear-buffer comint-mode-map)
#+end_src

*** COMMENT Geiser
    Geiser fucking annoyes me. Asks everytime when I open an =ss= file for scheme implementation
    #+BEGIN_SRC emacs-lisp
(use-package geiser
  :config
  (setq geiser-chez-binary "scheme")
  (setq geiser-default-implementation 'chez)
  ;; need to reopen the file for that.. heh
  (setq geiser-implementations-alist '	
	(
	 ;;((regexp "\\.scm$") guile)
	 ((regexp "\\.ss$") chez)
	 ((regexp "\\.rkt$") racket))
)
  ;;:init (add-hook 'scheme-mode-hook 'geiser-mode)
  ;; :bind(
  ;; 	:map geiser-mode-map
  ;; 	("C-<return>" . geiser-eval-defition)
  ;; 	("M-<return>" . geiser-eval-last-sexp)
  ;; 	)
  )
    #+END_SRC

*** cmuscheme

    #+BEGIN_SRC emacs-lisp
(use-package cmuscheme
  :load-path "elisp/"
  :bind(
	:map scheme-mode-map
	;; ("C-<return>" . scheme-send-definition)
	;; ("M-<return>" . scheme-send-last-sexp)
	)
  )
    #+END_SRC
   
*** s7 scheme + (ns)
    #+BEGIN_SRC emacs-lisp
(use-package aod-s7
  :load-path "elisp/"
  ;; the after apparently is needed..
  ;; if not, the bindings are not there even if in a scheme file
  ;; and having started a scheme with (run-scheme)
  :after (cmuscheme)
  :bind(
	:map scheme-mode-map
	("C-<return>" . aod.s7/send-definition)
	("M-<return>" . aod.s7/send-last-sexp)
	)
  )
    #+END_SRC

*** s7bi pd

    #+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.s7pd\\'" . scheme-mode))
(use-package s7bi-pd
  :load-path "elisp/"
  :commands (aod/s7bi-pd-mode)
  )
    #+END_SRC
*** COMMENT windows path
<2021-12-08 Wed> =:tangle (when )= doesn't work
    #+BEGIN_SRC emacs-lisp :tangle (when (eq system-type 'windows-nt) "yes")
(add-to-list 'exec-path "c:/Program Files/Chez Scheme 9.5.2/bin/ta6nt/")
    #+END_SRC
** Rust
   #+BEGIN_SRC emacs-lisp
(use-package rust-mode)   
   #+END_SRC
** PHP
   #+BEGIN_SRC emacs-lisp
(use-package php-mode)
   #+END_SRC
** JavaScript
   #+begin_src emacs-lisp
(use-package js2-mode
  :mode "\\.js\\'"
  :config
  (setq js2-strict-missing-semi-warning nil))
   #+end_src
** TypeScript
   #+begin_src emacs-lisp
(use-package typescript-mode)
   #+end_src
** etc (modes for syntax highligtin)
   #+BEGIN_SRC emacs-lisp
(use-package yaml-mode)
(use-package csv-mode)
(use-package meson-mode)
(use-package cmake-mode)
   #+END_SRC
** CC: c/c++

    #+begin_src emacs-lisp
(use-package cc-mode
  :config
  (message "here, cc-mode")
  :bind (:map c-mode-base-map
	      ("M-n" . end-of-defun)
	      ("M-p" . beginning-of-defun)))
    #+end_src

    #+begin_src emacs-lisp
(defun aod/cc-hook ()
  ;; https://github.com/google/styleguide/blob/gh-pages/google-c-style.el
  ;; download: it's under elisp/
  (require 'google-c-style)
  (google-set-c-style)
  (c-set-style "Google"))

(add-hook 'c-mode-common-hook #'aod/cc-hook)
    #+end_src
*** formatting
    #+begin_src emacs-lisp
(use-package clang-format)
    #+end_src

    a useful hook then is:
    #+begin_src emacs-lisp :tangle nil
(add-hook 'before-save-hook #'clang-format-buffer)
    #+end_src
** groovy
   #+begin_src emacs-lisp
(use-package groovy-mode)
   #+end_src
** python
   #+begin_src emacs-lisp
(with-eval-after-load 'org
  (org-babel-do-load-languages 'org-babel-load-languages
			       '((python . t)))
  (setq org-babel-python-command (or
				  (executable-find "python3")
				  (executable-find "python")
				  (prong (warn "Could not find python executable")
					 nil))))
   #+end_src

* Debug
** gdb
- https://stackoverflow.com/questions/20990795/can-emacs-gdb-mode-display-expressions-in-separate-window
#+begin_src emacs-lisp
(use-package gdb-mi
  :ensure nil
  :config
  (setq gdb-many-windows t
	gdb-show-main t))

'(with-eval-after-load 'gdb
	 (setq gdb-many-windows t
	       gdb-show-main t))
#+end_src

*** gdb hydra
https://github.com/weirdNox/dotfiles/blob/c216e6c8d1cb96855c569768f42f8a4311eb27e2/config/.emacs.d/init.el#L440
#+begin_src emacs-lisp
(defhydra hydra-gdb (:exit nil :foreign-keys run)
  "gdb"
  ;; ("O" gdb :exit t)
  ;; ("k" nox/gdb-kill :exit t)
  ("R" gud-run "run" :exit t)
  ("c" gud-cont "continue")
  ;; ("s" nox/gdb-stop :exit t)
  ("b" gud-break "break")
  ("t" gud-tbreak "tbreak?")
  ("r" gud-remove "remove")
  ("n" gud-next "next")
  ("N" gud-nexti "nexti")
  ("i" gud-step "step")
  ("I" gud-stepi "stepi")
  ("o" gud-finish "finish")
  ("u" gud-until "until")
  ;; ("w" nox/gdb-watch :exit t)
  ;; ("S" (lambda () (interactive) (setq nox/gdb-disassembly-show-source
  ;;                                     (not nox/gdb-disassembly-show-source))))
  ("q" ignore :exit t)
  ("C-g" ignore :exit t))
#+end_src

*** COMMENT sr speedbar (speedbar in same frame)
not useful
speedbar is used by gdb for watched variabless.

#+begin_src emacs-lisp
(use-package sr-speedbar)
#+end_src
** dap
  #+begin_src emacs-lisp
(use-package dap-mode
  :config
  (require 'dap-cpptools)
  (require 'dap-gdb-lldb)
  (require 'dap-lldb)
  (setq dap-lldb-debug-program '("/usr/bin/lldb-vscode-12")))
  #+end_src
  run =dap-cpptools-setup= and =dap-gdb-lldb-setup=
  also (cause lldb-mi is needed)
  #+begin_src sh
sudo apt install lldb
  #+end_src

- ext install webfreak.debug
  - https://www.reddit.com/r/emacs/comments/mxiqt6/how_to_setup_and_use_dapmode_for_c/
  - https://github.com/emacs-lsp/dap-mode/issues/69
  #+begin_src sh
rsync -a /home/actondev/.vscode/extensions/webfreak.debug-0.25.1/ ~/.emacs.d/.extension/vscode/webfreak.debug/extension
  #+end_src
** COMMENT weirdNox/emacs-gdb: rewrite
https://github.com/weirdNox/emacs-gdb
https://github.com/weirdNox/emacs-gdb#default-keybindings
#+begin_src emacs-lisp
(use-package gdb-mi :quelpa (gdb-mi :fetcher git
                                    :url "https://github.com/weirdNox/emacs-gdb.git"
                                    :files ("*.el" "*.c" "*.h" "Makefile"))
  :init
  (fmakunbound 'gdb)
  (fmakunbound 'gdb-enable-debug))
#+end_src
** realgud
#+begin_src emacs-lisp
(use-package realgud)
#+end_src
* Web
** restclient
   Associating with =.http= files
   #+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t
  :mode ("\\.http\\'" . restclient-mode)
  )
   #+END_SRC

   Allowing restclient snippets in org-mode
   + [ ] how can i load this? 
   #+BEGIN_SRC emacs-lisp
(use-package ob-restclient
  :init ; init is ran before a package is loaded
  (with-eval-after-load 'org
    (require 'ob-restclient))
  :config
  (org-babel-do-load-languages 'org-babel-load-languages
			       '((restclient . t))))
   #+END_SRC
** TODO ob-http
   https://github.com/zweifisch/ob-http

   this vs restclient?

* Documentation
  Note: first install zeal
  #+begin_src sh :tangle no
sudo apt-get install zeal
  #+end_src

  #+begin_src emacs-lisp
(use-package zeal-at-point
  :bind
  (("C-c d" . zeal-at-point)))
  #+end_src

  Note: js docs are acting weird
  Solution (<2021-01-28 Thu>): find react-main.01db16f317c6.js in =~/.local/share/zeal= and delete it (there were 2, deleted both)
* "command" bindings: C-; C-,

** window & tabs
   #+begin_src emacs-lisp
(global-set-key (kbd "C-; C-w") #'windmove-up)
(global-set-key (kbd "C-; C-a") #'windmove-left)
(global-set-key (kbd "C-; C-s") #'windmove-down)
(global-set-key (kbd "C-; C-d") #'windmove-right)

(defun aod/delete-window-or-tab ()
  (interactive)
  (if (window-parent (selected-window))
      (delete-window)
    (tab-close)))

(global-set-key (kbd "C-; C-q") #'aod/delete-window-or-tab)

(global-set-key (kbd "C-; C-e") #'delete-other-windows)

(global-set-key (kbd "C-; C-t") #'tab-switch)

(defun aod-window/split-vertical+down ()
  (interactive)
  (split-window-vertically) (other-window 1))

(defun aod-window/split-horizontal+right ()
  (interactive)
  (split-window-horizontally) (other-window 1))

(global-set-key (kbd "C-; C-r") #'windresize)

;; (global-set-key (kbd "C-; C-h") #'aod-window/split-horizontal+right)
;; (global-set-key (kbd "C-; C-v") #'aod-window/split-vertical+down)

;; alternative: f: right from d -> split right
;; alternative: x: down from s -> split down
(global-set-key (kbd "C-; C-f") #'aod-window/split-horizontal+right)
(global-set-key (kbd "C-; C-x") #'aod-window/split-vertical+down)
(global-set-key (kbd "C-; C-v") #'aod-window/split-vertical+down)
   #+end_src
** COMMENT helm & avy
   #+begin_src emacs-lisp
(global-set-key (kbd "C-, C-r") 'helm-all-mark-rings) ;; Rings
(global-set-key (kbd "C-, C-m") 'helm-mini) ;; Mini
(global-set-key (kbd "C-, C-s") 'helm-swoop) ;; Swoop
(global-set-key (kbd "C-, C-t") 'helm-projectile-find-file) ;; projecTile
(global-set-key (kbd "C-, C-v") 'aod/avy)
;; helm-projectile-ag gives me bug in window, use projectile-ag? ..
(global-set-key (kbd "C-, C-a") 'helm-projectile-ag)
   #+end_src
** consult
   Tips
   - cosult-ripgrep
     - add =-- -tcpp= ad the end of the query to search only cpp files.
       You can run =rg --type-list= to see all the available types
   #+begin_src emacs-lisp
(global-set-key (kbd "C-, C-m") 'consult-buffer) ;; ala helm-mini
(global-set-key (kbd "C-, C-t") 'project-find-file) ;; projecT
(global-set-key (kbd "C-, C-r") 'consult-ripgrep)
(global-set-key (kbd "C-, C-a") 'consult-ripgrep) ;; ala ag
;; (global-set-key (kbd "C-, C-r") 'consult-recent-file)
(global-set-key (kbd "C-, C-l") 'consult-line)
(global-set-key (kbd "C-, C-i") 'consult-imenu)
   #+end_src
** region expand/contract
   #+begin_src emacs-lisp
(global-set-key (kbd "C-, C-.") 'er/expand-region) ;; >: expand (. shifted)
(global-set-key (kbd "C-, C-,") 'er/contract-region) ;; <: expand (, shifted)
   #+end_src
** COMMENT Key-chord
   #+BEGIN_SRC emacs-lisp
(defun key-chord-helm ()
  ;; helm: , (right hand middle finger)
  (key-chord-define-global ",r" 'helm-all-mark-rings) ;; Rings
  (key-chord-define-global ",m" 'helm-mini) ;; Mini
  (key-chord-define-global ",s" 'helm-swoop) ;; Swoop
  (key-chord-define-global ",t" 'helm-projectile-find-file) ;; projecTile
  ;; helm-projectile-ag gives me bug in window, use projectile-ag? .. 
  (key-chord-define-global ",g" 'helm-projectile-ag) ;; aG
  )

;; TODO remove it. use avy
;; (defun key-chord-ace-jump ()
;;   ;; ace: c (c for jump : left hand middle finger)
;;   (key-chord-define-global "cj" 'ace-jump-mode)
;;   ;; Jump Character
;;   (key-chord-define-global "ck" 'ace-jump-char-mode)
;;   ;; Jump Line
;;   (key-chord-define-global "cl" 'ace-jump-line-mode)
;;   )

(defun key-chord-windows-management ()
  ;; move between windows -WASD- like movement, except for the right hand
  ;; using ;
  (key-chord-define-global ";w" 'windmove-up)
  (key-chord-define-global ";a" 'windmove-left)
  (key-chord-define-global ";s" 'windmove-down)
  (key-chord-define-global ";d" 'windmove-right)

  ;; windows
  (key-chord-define-global ";q" 'delete-window) ;;q Quit
  (key-chord-define-global ";e" 'delete-other-windows)
  (key-chord-define-global ";f" (lambda () (interactive)(split-window-horizontally) (other-window 1))) ;; f home row
  (key-chord-define-global ";v" (lambda () (interactive)(split-window-vertically) (other-window 1))) ;; Vertical

  (key-chord-define-global ";r" 'windresize) ;; Resize
  )

(defun key-chord-editing ()
  ;; Expand Region (r for region)
  (key-chord-define-global "e3" 'er/expand-region)
  (key-chord-define-global "e2" 'er/contract-region)
  )

(defun key-chord-dot ()
  ;; with dot . prefix
  ;; 
  ;; putting the key sequence cause for example org-mode does its thing
  (key-chord-define-global ".s" "\C-x\C-s")
  (key-chord-define-global ".f" 'helm-find-files)
  (key-chord-define-global ".g" 'keyboard-quit)
  (key-chord-define-global ".c" "\C-c\C-c")
  (key-chord-define-global ".k" "\C-x\k")
  ;; (key-chord-define-global ".z" 'undo-tree-undo)
  ;; (key-chord-define-global ".d" "\C-d")
  (key-chord-define-global ".e" "\C-e")
  (key-chord-define-global ".a" "\C-a")
  )

;; TODO could I use tab..?

;;(defun key-chord-backslash ()
;; (key-chord-define-global [?\\ ?w] '(lambda () (message "hi")))
;;  (key-chord-define-global "\\q" 'keyboard-quit)
;;  )

(use-package key-chord
  :hook (after-init . key-chord-mode)
  :config
  ;; disable in mini buffers
  (setq key-chord-two-keys-delay .05
	key-chord-one-key-delay .1)
  (defun disable-key-chord-mode ()
    (set (make-local-variable 'input-method-function) nil))

  (add-hook 'minibuffer-setup-hook #'disable-key-chord-mode)
  (key-chord-mode 1)

  ;; (key-chord-helm)
  (key-chord-windows-management)
  (key-chord-editing)
  ;; (key-chord-ace-jump)
  (key-chord-dot)
  (key-chord-define-global ",v" 'aod/avy)
  )
   #+END_SRC

** Which key
   https://github.com/justbur/emacs-which-key
   Get a feedback about the current key sequences, what can i press afterwards?
   #+BEGIN_SRC emacs-lisp
(use-package which-key
  ;; :hook (after-init . which-key-mode)
  :defer 0
  :config
  (which-key-mode)
  (which-key-enable-god-mode-support)
  (setq which-key-idle-delay 0.5) ;; default: 1
  )
   #+END_SRC

** Buttons
   See https://github.com/rolandwalker/button-lock/issues/14 (solved)

   #+BEGIN_SRC emacs-lisp
(use-package button-lock
  :load-path "elisp/"
  :commands (button-lock-mode button-lock-set-button)
  :config
  ;; styling after custom-button & custom-button-mouse
  (set-face-attribute 'button-lock-button-face nil
		      :foreground "#268bd2"
		      :background "#1c1e1f"
		      :box '(:line-width 1 :style none))
  (set-face-attribute 'button-lock-mouse-face nil
		      :foreground "#1c1e1f"
		      :background "#268bd2"
		      :box '(:line-width 1 :style none))
  )
   #+END_SRC

   example
   (note: the function should be =(interactive)= cause it's needed by =define-key=)
   #+BEGIN_SRC emacs-lisp :tangle no
(button-lock-mode 1)
(defun button/say-hi ()
  "Shout when clicked"
  (interactive)
  (message "hi there!")
)

(button-lock-set-button (regexp-quote ">say-hi")
			'button/say-hi
			:face 'link )
   #+END_SRC
   >say-hi

   #+BEGIN_SRC emacs-lisp :tangle no
(button-lock-clear-all-buttons)
   #+END_SRC
** caps-lock
   #+begin_src emacs-lisp
(use-package caps-lock)
   #+end_src

   #+begin_src emacs-lisp
(defun aod/caps-lock ()
  (interactive)
  (let ((choices '((?r "reset" "setxkbmap -option")
		   (?n "nocaps" "setxkbmap -option ctrl:nocaps")
		   (?s "swapcaps" "setxkbmap -option ctrl:swapcaps"))))
    (let ((choice (read-multiple-choice "caps lock mode:" choices)))
      (shell-command (caddr choice)))))
   #+end_src

   The commands:
   #+begin_src sh :tangle no
setxkbmap -option # reset
setxkbmap -option ctrl:nocaps # ctrl & caps act as control
setxkbmap -option ctrl:swapcaps # ctrl is caps & caps is control
   #+end_src
** hercules
   #+begin_src emacs-lisp
(use-package general)
(use-package hercules)
   #+end_src
** aod-do
   #+begin_src emacs-lisp
(use-package aod-do
  :load-path "elisp/"
  :defer 0
  )

;;(key-chord-define-global "/d" #'aod-do/action-interactive)
(global-set-key (kbd "C-, C-d") 'aod-do/action-interactive)
   #+end_src
* Presentation
** org modern mode
   #+begin_src emacs-lisp
(use-package org-modern)
   #+end_src
** olivetti
   =foo=
   #+begin_src emacs-lisp
(use-package olivetti
  :config
  (setq olivetti-body-width 0.7
	olivetti-minimum-body-width 80
	olivetti-recall-visual-line-mode-entry-state t))
   #+end_src
** logos (narrowing, forward/backward)
   #+begin_src emacs-lisp
(use-package logos
  :config
  (setq logos-outlines-are-pages t)
  (setq-default logos-hide-cursor nil
		logos-hide-mode-line t
		logos-hide-buffer-boundaries t
		logos-hide-fringe t
		logos-variable-pitch nil
		logos-buffer-read-only t
		logos-scroll-lock nil
		logos-olivetti t))
   #+end_src
** present-mode

   #+begin_src emacs-lisp
(setq aod.logos/present-mode-map (make-sparse-keymap))
(define-minor-mode aod.logos/present-mode
  "Toggle present mode"
  :init-value nil
  :lighter "present"
  :keymap aod.logos/present-mode-map
  (if aod.logos/present-mode
      (progn
	(logos-narrow-dwim)
	(logos-focus-mode 1)
	(logos--mode 'menu-bar-mode -1)
	(logos--mode 'tool-bar-mode -1)
	(logos--mode 'display-line-numbers-mode -1)
	(logos--mode 'org-modern-mode 1)
	(setq-local aod.log/org-hide-emphasis-markers org-hide-emphasis-markers)
	(setq-local org-hide-emphasis-markers t)
	;; trigger update for org-hide-emphasis-markers
	(font-lock-mode 1)
	)
    (progn
      (logos-focus-mode -1)
      (setq-local org-hide-emphasis-markers aod.log/org-hide-emphasis-markers)
      (widen))))

(define-key aod.logos/present-mode-map (kbd "[") 'logos-backward-page-dwim)
(define-key aod.logos/present-mode-map (kbd "]") 'logos-forward-page-dwim)
(define-key aod.logos/present-mode-map (kbd "q") 'aod.logos/present-mode)
   #+end_src
** command log
   #+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :commands global-command-log-mode)
   #+END_SRC
   Usage:
   - global-command-log-mode
   - clm/open-command-log-buffer

* Windows

** mouse wheel fix (29.0.60)
   #+begin_src emacs-lisp
;; event-line-count is supposed to return a positive value
;; but in windows it can return negative values!
;; this fucks up mwheel-scroll
(defun aod.windows/event-line-count-fix (line-count)
  ;; (message "here line-count %s" line-count)
  (abs line-count))

(when (eq system-type 'windows-nt)
  (advice-add 'event-line-count :filter-return #'aod.windows/event-line-count-fix)
  ;; re-evaluate mwheel-scroll which calls event-line-count
  (save-window-excursion (find-function 'mwheel-scroll) (eval-defun 0))
  ;; (byte-compile 'mwheel-scroll)
  ;; (require 'mwheel)
  ;; (package-recompile 'mwheel)
  ;; (load-file "mwheel.el.gz")
  ;; (load "mwheel")
  )
   #+end_src
* COMMENT Old Windows snippets
  :PROPERTIES:
  :header-args: :tangle (when (eq system-type 'windows-nt) "yes")
  :END:

<2021-12-08 Wed> =:tangle (when )= doesn't work
** MSYS2 bash
   (hm.. git bash is better)

   By default
   - explicit-shell-file-name is nil
   - explicit-bash.exe-args .. doesn't exist
   #+BEGIN_SRC emacs-lisp
(setq explicit-shell-file-name "c:/msys64/usr/bin/bash.exe")
;; so.. --login is fucking things up. like this it's perfect :D
;; also there is the --noprofile flag. not sure if I need it
(setq explicit-bash.exe-args '("--rcfile" "~/.emacs.d/dot/.bashrc" "-i"  ))
   #+END_SRC

   #+RESULTS:
   | --rcfile | ~/.emacs.d/dot/.bashrc | -i |

   #+BEGIN_SRC emacs-lisp
(defun my-on-shell-cd-error (e)
  (message "error"))

(add-hook 'shell-set-directory-error-hook  'my-on-shell-cd-error)
   #+END_SRC

   #+RESULTS:
   | --login | -i |

** COMMENT Git bash
   #+BEGIN_SRC emacs-lisp
(setq explicit-shell-file-name "c:/Program Files/Git/bin/bash.exe")
(setq explicit-bash.exe-args '("--login" "-i"))
   #+END_SRC

   #+RESULTS:
   | --login | -i |

   From https://emacs.stackexchange.com/questions/22049/git-bash-in-emacs-on-windows

** Windows bash
   #+BEGIN_SRC emacs-lisp
(defun my-bash-on-windows-shell ()
  (interactive)
  (let ((explicit-shell-file-name "C:/Windows/System32/bash.exe")
	(explicit-bash.exe-args '("--rcfile" "<(echo \"PS1='foo: '\")>" ))	
	)
    (shell)))
   #+END_SRC

   #+RESULTS:
   : my-bash-on-windows-shell

** lsp clojure fix
   #+BEGIN_SRC emacs-lisp
(setq lsp-clojure-server-command '("clojure-lsp.bat"))
   #+END_SRC

** paths: msys2
   Really useful for stuff like =ediff= etc..
   #+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (let (
        (mypaths
         '(
           "C:/msys64/mingw64/bin"
	   "C:/msys64/usr/local/bin"
	   "C:/msys64/usr/bin"
	   "C:/msys64/usr/bin"
	   "C:/msys64/usr/bin/site_perl"
	   "C:/msys64/usr/bin/vendor_perl"
	   "C:/msys64/usr/bin/core_perl"
           ) )
        )

    (setenv "PATH" (concat
		    (mapconcat 'identity mypaths ";")
                    (getenv "PATH")
		    ";"
		    "c:/Program Files/Chez Scheme 9.5.2/bin/ta6nt"
		    ";"
		    
		    ))

    ;;(setq exec-path (append mypaths (list "." exec-directory)) )
    (setq exec-path (append exec-path mypaths (list exec-directory)))
    ))

   #+END_SRC

   #+RESULTS:
   | c:/Program Files/Chez Scheme 9.5.2/bin/ta6nt/ | c:/Program Files/Broadcom/Broadcom 802.11 Network Adapter | C:/Python37/Scripts/ | C:/Python37/ | C:/Program Files (x86)/Common Files/Oracle/Java/javapath | C:/WINDOWS/system32 | C:/WINDOWS | C:/WINDOWS/System32/Wbem | C:/WINDOWS/System32/WindowsPowerShell/v1.0/ | C:/WINDOWS/System32/OpenSSH/ | C:/ProgramData/chocolatey/bin | c:/Program Files/Intel/WiFi/bin/ | c:/Program Files/Common Files/Intel/WirelessCommon/ | C:/Program Files/Microsoft VS Code | C:/Program Files/MiKTeX 2.9/miktex/bin/x64/ | C:/Program Files/Microsoft VS Code/bin | C:/Program Files/nodejs/ | C:/Users/actondev/AppData/Local/Android/Sdk/platform-tools/ | C:/Program Files/gnuplot/bin | C:/ProgramData/chocolatey/lib/lua53/tools | C:/Program Files/Mullvad VPN/resources | C:/tools/php74 | C:/ProgramData/ComposerSetup/bin | C:/Program Files/Git/cmd | C:/D/dmd2/windows/bin | C:/Program Files/Janet-1.9.1/bin | C:/Users/actondev/.cargo/bin | C:/Users/actondev/AppData/Local/Microsoft/WindowsApps | C:/Users/actondev/bin | c:/Program Files/Intel/WiFi/bin/ | c:/Program Files/Common Files/Intel/WirelessCommon/ | C:/Users/actondev/AppData/Roaming/npm | C:/gradle/gradle-2.2/bin | C:/Users/actondev/watchman | C:/Program Files/VideoLAN/VLC | C:/Program Files/Java/jdk-11.0.5/bin | C:/Users/actondev/AppData/Roaming/Composer/vendor/bin | C:/ProgramData/chocolatey/lib/mingw/tools/install/mingw64/bin | C:/Program Files/CMake/bin | W:/dev/_sdk/sciter/bin.win/x64 | C:/Users/actondev/bin/zig-windows-x86_64-0.6.0 | C:/Program Files/Chez Scheme 9.5.2/bin/ta6nt | . | w:/portables/emacs-26.3-x86_64/libexec/emacs/26.3/x86_64-w64-mingw32 | C:/msys64/mingw64/bin | C:/msys64/usr/local/bin | C:/msys64/usr/bin | C:/msys64/usr/bin | C:/msys64/usr/bin/site_perl | C:/msys64/usr/bin/vendor_perl | C:/msys64/usr/bin/core_perl | w:/portables/emacs-26.3-x86_64/libexec/emacs/26.3/x86_64-w64-mingw32/ | C:/msys64/mingw64/bin | C:/msys64/usr/local/bin | C:/msys64/usr/bin | C:/msys64/usr/bin | C:/msys64/usr/bin/site_perl | C:/msys64/usr/bin/vendor_perl | C:/msys64/usr/bin/core_perl | w:/portables/emacs-26.3-x86_64/libexec/emacs/26.3/x86_64-w64-mingw32/ |

** Spellcheck (flyspell & hunspell)
   See [[https://emacs.stackexchange.com/questions/14952/how-do-i-set-up-hunspell-on-a-windows-pc][this discussion]] for details. Long story short, I was getting the following error
   #+BEGIN_SRC text
Error enabling Flyspell mode:
(Canâ€™t find Hunspell dictionary with a .aff affix file)  
   #+END_SRC

   The problem was that upon running the following code
   #+BEGIN_EXAMPLE emacs-lisp
  '(call-process ispell-program-name
	      null-device
	      t
	      nil
	      "-D"
	      "-a"
	      null-device
	      )
   #+END_EXAMPLE
   I should get at least one line with the files =.dic= and =.aff=. But it wasn't happening (yet in ubuntu yeah)

   The solution was the following

   #+BEGIN_SRC emacs-lisp
'(setenv "DICTIONARY" "en_US")
   #+END_SRC

   Add greek dictionary

   #+BEGIN_SRC emacs-lisp
(require 'ispell)
(add-to-list 'ispell-local-dictionary-alist '("el"
                                              "[[:alpha:]]"
                                              "[^[:alpha:]]"
                                              "[']"
                                              t
                                              ("-d" "el"); Dictionary file name
                                              nil
					      ;; nil
					      utf-8
                                              ;;    iso-8859-1
					      ))

(add-to-list 'ispell-local-dictionary-alist '("el,en,es"
                                              "[[:alpha:]]"
                                              "[^[:alpha:]]"
                                              "[']"
                                              t
                                              ("-d" "el"); Dictionary file name
                                              nil
					      ;; nil
					      utf-8
                                              ;;    iso-8859-1
					      ))
   #+END_SRC

   #+RESULTS:
   | el    | [[:alpha:]] | [^[:alpha:]] | ['] | t | (-d el) | nil | utf-8      |       |
   | el    | [[:alpha:]] | [^[:alpha:]] | ['] | t | nil     | nil | nil        | utf-8 |
   | greek | [[:alpha:]] | [^[:alpha:]] | ['] | t | nil     | nil | nil        | utf-8 |
   | greek | [[:alpha:]] | [^[:alpha:]] | ['] | t | (-d el) | nil | iso-8859-1 |       |

   Multiple languages
   #+BEGIN_SRC emacs-lisp
'(setq ispell-dictionary nil)
'(setq ispell-dictionary "el,en,es")
   #+END_SRC

   #+RESULTS:
   : el,en,es

** Perfromance on windows
   [[file:w:/portables/emacs-26.3-x86_64/bin/runemacs.exe]]
   w:/portables/emacs-26.3-x86_64/bin/runemacs.exe
   
https://www.reddit.com/r/emacs/comments/bii2xl/hot_tip_for_windows_10_users/
   http://code.kliu.org/misc/elevate/
   #+BEGIN_SRC sh :tangle no
   # getting the shell executable
/bin/start cmd

echo "test" > /c/test-file
elevate2.exe 
cygstart --action=runas 

elevate.exe -k $(echo $(cygpath.exe -w -a $SHELL) --login)
elevate.exe -k -wait cmd
echo $(cygpath.exe -w -a $SHELL) --login

cygpath.exe -w -a $SHELL

fsutil.exe behavior set disable8dot3 1

fsutil.exe behavior set disableLastAccess 3

powershell -Command Add-MpPreference -ExclusionPath $(echo ~/.emacs.d)

powershell -Command Add-MpPreference -ExclusionProcess "emacs-w32.exe"

powershell -Command Add-MpPreference -ExclusionProcess "emacsclient-w32.exe"

powershell -Command Add-MpPreference -ExclusionExtension ".el"

powershell -Command Add-MpPreference -ExclusionExtension ".elc"
   #+END_SRC
** TODO COMMENT dired fix?
   Update: apparently it didn't work. it says that filed moved but.. nope!

   When renaming a file in dired (with =R=, I cannot move it in a directory that doesn't exist. See [[file:emacs-lisp/dired-fix.el]] . Fix found in a [[https://lists.gnu.org/archive/html/emacs-devel/2011-12/msg00253.html][GNU mail discussion]].
   Notes
   + =string-starts-with= doesn't exist
     replaced with =string-prefix-p=
   #+BEGIN_SRC emacs-lisp
(load-file (relative-from-init "elisp/dired-fix.el"))
   #+END_SRC

* Linux
<2021-12-08 Wed> =:tangle (when )= doesn't work
#+begin_src org-
:PROPERTIES:
:header-args: :tangle (when (eq system-type 'gnu/linux) "yes") :results silent
:END:
#+end_src

** Open as sudo
   https://emacsredux.com/blog/2013/04/21/edit-files-as-root/
   #+BEGIN_SRC emacs-lisp
(defun er-sudo-edit (&optional arg)
  "Edit currently visited file as root.

With a prefix ARG prompt for a file to visit.
Will also prompt for a file to visit if current
buffer is not visiting a file."
  (interactive "P")
  (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:"
                         (read-file-name "Find file(as root): ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
   #+END_SRC

** COMMENT sudo save
   #+BEGIN_SRC emacs-lisp
(use-package sudo-save)   
   #+END_SRC

   #+RESULTS:

** COMMENT Sudo save nah
   #+BEGIN_SRC emacs-lisp :tangle no
(defun sudo-before-save-hook ()
  (set (make-local-variable 'sudo:file) (buffer-file-name))
  (when sudo:file
    (unless(file-writable-p sudo:file)
      (set (make-local-variable 'sudo:old-owner-uid) (nth 2 (file-attributes sudo:file)))
      (when (numberp sudo:old-owner-uid)
	(unless (= (user-uid) sudo:old-owner-uid)
	  (when (y-or-n-p
		 (format "File %s is owned by %s, save it with sudo? "
			 (file-name-nondirectory sudo:file)
			 (user-login-name sudo:old-owner-uid)))
	    (sudo-chown-file (int-to-string (user-uid)) (sudo-quoting sudo:file))
	    (add-hook 'after-save-hook
		      (lambda ()
			(sudo-chown-file (int-to-string sudo:old-owner-uid)
					 (sudo-quoting sudo:file))
			(if sudo-clear-password-always
			    (sudo-kill-password-timeout)))
		      nil   ;; not append
		      t	    ;; buffer local hook
		      )))))))


(add-hook 'before-save-hook 'sudo-before-save-hook)
   #+END_SRC
* COMMENT Troubleshooting etc
** checking executables
   #+BEGIN_SRC emacs-lisp
(message "do you see me?")
(executable-find "ag")
   #+END_SRC

** windows ag problem
   see https://github.com/bbatsov/helm-projectile/issues/90
   + choco uninstall ag
   + choco install ag --version 0.29.1.1641

* COMMENT notes
  #+BEGIN_SRC emacs-lisp
;; customize inital screen
(customize-group 'initialization)
  #+END_SRC
** cua mode

   #+BEGIN_SRC text
`cua--ena-cua-keys-keymap' Minor Mode Bindings:
key             binding
---             -------

C-c		Prefix Command
C-v		yank
C-x		Prefix Command
C-z		undo
ESC		Prefix Command

M-v		delete-selection-repeat-replace-region

C-c <timeout>	copy-region-as-kill

C-x <timeout>	kill-region   
   #+END_SRC
** org sh sessions example
   #+BEGIN_SRC sh :session *sh1*
echo hi
echo hi2
   #+END_SRC

   #+BEGIN_SRC sh :session *sh2*
echo "hi from sh2"
echo hi2
   #+END_SRC

   #+BEGIN_SRC sh
echo "hi from default"
   #+END_SRC
* TODO ideas to check
  + org mode : linking to certain line (can do already but, to point to the line where a function is declared?)
    https://endlessparentheses.com/use-org-mode-links-for-absolutely-anything.html
    
* COMMENT spelling notes
  :PROPERTIES:
  :header-args: :results output replace
  :END:

  listing dictionaries
  #+BEGIN_SRC sh :results output replace
hunspell -D 2>&1
  #+END_SRC

  #+RESULTS:
  #+begin_example
  SEARCH PATH:
  .;C:/msys64/mingw64/bin/;C:/msys64/mingw64/share/hunspell;C:/msys64/mingw64/share/myspell;C:/msys64/mingw64/share/myspell/dicts;C:/msys64;%USERPROFILE%/Application Data/OpenOffice.org 2/user/wordbook;C:/msys64/mingw64/share/dict/ooo;
  AVAILABLE DICTIONARIES (path is not mandatory for -d option):
  C:/msys64/mingw64/share/hunspell/el_GR
  C:/msys64/mingw64/share/hunspell/en_AG
  C:/msys64/mingw64/share/hunspell/en_AU-large
  C:/msys64/mingw64/share/hunspell/en_AU
  C:/msys64/mingw64/share/hunspell/en_BS
  C:/msys64/mingw64/share/hunspell/en_BW
  C:/msys64/mingw64/share/hunspell/en_BZ
  C:/msys64/mingw64/share/hunspell/en_CA
  C:/msys64/mingw64/share/hunspell/en_DK
  C:/msys64/mingw64/share/hunspell/en_GB
  C:/msys64/mingw64/share/hunspell/en_GH
  C:/msys64/mingw64/share/hunspell/en_HK
  C:/msys64/mingw64/share/hunspell/en_IE
  C:/msys64/mingw64/share/hunspell/en_IN
  C:/msys64/mingw64/share/hunspell/en_JM
  C:/msys64/mingw64/share/hunspell/en_NA
  C:/msys64/mingw64/share/hunspell/en_NG
  C:/msys64/mingw64/share/hunspell/en_NZ
  C:/msys64/mingw64/share/hunspell/en_PH
  C:/msys64/mingw64/share/hunspell/en_SG
  C:/msys64/mingw64/share/hunspell/en_TT
  C:/msys64/mingw64/share/hunspell/en_US-large
  C:/msys64/mingw64/share/hunspell/en_US
  C:/msys64/mingw64/share/hunspell/en_ZA
  C:/msys64/mingw64/share/hunspell/en_ZW
  #+end_example

**  <2020-04-21 Tue> aspell 
   <2020-04-21 Tue> trying aspell
   pacman -S mingw64/mingw-w64-x86_64-aspell mingw64/mingw-w64-x86_64-aspell-en mingw64/mingw-w64-x86_64-aspell-es


   #+BEGIN_SRC sh
aspell dicts
   #+END_SRC

   #+RESULTS:
   #+begin_example
   el
   en
   en-variant_0
   en-variant_1
   en-variant_2
   en-w_accents
   en-wo_accents
   en_AU
   en_AU-variant_0
   en_AU-variant_1
   en_AU-w_accents
   en_AU-wo_accents
   en_CA
   en_CA-variant_0
   en_CA-variant_1
   en_CA-w_accents
   en_CA-wo_accents
   en_GB
   en_GB-ise
   en_GB-ise-w_accents
   en_GB-ise-wo_accents
   en_GB-ize
   en_GB-ize-w_accents
   en_GB-ize-wo_accents
   en_GB-variant_0
   en_GB-variant_1
   en_GB-w_accents
   en_GB-wo_accents
   en_US
   en_US-variant_0
   en_US-variant_1
   en_US-w_accents
   en_US-wo_accents
   es
   gr
   #+end_example

   #+BEGIN_SRC sh :results replace pp
echo dont | aspell -a
echo habia | aspell -l es -a
echo "Î³ÎµÎ¹Î±" | aspell -a -l el
   #+END_SRC

   #+RESULTS:

** Installing greek
   - from https://ftp.gnu.org/gnu/aspell/dict/0index.html get the greek
   - extract
   - (now with msys2 terminal)
   - cd into the extracted
   - edit the makefil
     - add quotes around all the "cd" instructions
   - ./configure
   - make
   - make install
   - =aspell dicts= now should list greek
